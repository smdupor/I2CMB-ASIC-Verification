<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="(C) Copyright 2020" />
<meta name="DC.rights.owner" content="(C) Copyright 2020" />
<meta name="DC.Type" content="CommandRefTopic" />
<meta name="DC.Title" content="mti_ForceSignal()" />
<meta name="abstract" content="Forces a value onto a VHDL signal." />
<meta name="description" content="Forces a value onto a VHDL signal." />
<meta name="DC.subject" content="mti_ForceSignal()" />
<meta name="keywords" content="mti_ForceSignal()" />
<meta name="prodname" content="Foreign Language Interface Manual" />
<meta name="version" content="2014.06" />
<meta name="release" content="v2014.06" />
<meta name="series" content="mgc_ih" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Publisher" content="Mentor Graphics Corporation 10 24 2014 10 24 2014 Fresh off the boat." />
<meta name="DC.Date.Created" content="0000-00-00" />
<meta name="DC.Date.Modified" content="2020-07-10" />
<meta name="VariantPrefix" content="none" />
<meta name="Tier" content="1" />
<meta name="SubTitle" content="Including Support for ModelSim® DE/SE and Questa® SIM" />
<meta name="SourceHandle" content="fli" />
<meta name="SoftwareVersionNum" content="2020.4" />
<meta name="SoftwareRelease" content="none" />
<meta name="RevHist" content="none" />
<meta name="PublicationDate" content="none" />
<meta name="Platform" content="none" />
<meta name="PartNumber" content="none" />
<meta name="LicenseType" content="EULA" />
<meta name="InfoHubHandle" content="mgc_ih" />
<meta name="EclipsePluginName" content="none" />
<meta name="DraftDate" content="none" />
<meta name="Draft" content="none" />
<meta name="DocumentTitle" content="Foreign Language Interface Manual" />
<meta name="CSHelp" content="no" />
<meta name="CSDSearchKeywords" content="product.version.2020.4,sort.order.100,doc.type.documentation.ref,product.id.P10467,product.id.P10593,product.id.P11632,product.id.P11633," />
<meta name="Copyright" content="READONLY - Use: copyrfirst and copyrlast" />
<meta name="ConditionFiltering" content="XML" />
<meta name="ChecklinksRelease" content="mti2020" />
<meta name="BookcaseHandle" content="none" />
<meta name="Beta" content="none" />
<meta name="Alpha" content="none" />
<meta name="ActiveStatus" content="Active" />
<meta name="GenerateOnlyChangedTopics" content="none" />
<meta name="HighlightChanges" content="none" />
<meta name="HighlightColor" content="Pale Green" />
<meta name="IncludeInInventory" content="yes" />
<meta name="SourceEDDVersion" content="12.2.10" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="idee5ba678-0680-48f3-bf29-7936d87b447a" />
<link rel="stylesheet" type="text/css" href="../commonltr.css" />
<title>mti_ForceSignal()</title>
<link rel="stylesheet" href="../../MGC/styles/mgcdita-lang.css" type="text/css" /><noscript><link rel="StyleSheet" href="../../MGC/styles/body.css" type="text/css" /><link rel="StyleSheet" href="../../MGC/styles/catalog.css" type="text/css" /><link rel="StyleSheet" href="../../MGC/styles/document.css" type="text/css" /><link rel="stylesheet" href="../../MGC/styles/mgcdita-lang.css" type="text/css" /></noscript><meta name="mgc_html_doctitle" content="mti_ForceSignal()" />
<meta name="attributes" content="product.version.2020.4,sort.order.100,doc.type.documentation.ref,product.id.P10467,product.id.P10593,product.id.P11632,product.id.P11633," />
<meta name="TEMPLATEBASE" content="mgc_mgchelp_v4.2.009" />
<script type="text/javascript" language="JavaScript1.2" src="../../MGC/js/page.js"></script><script type="text/javascript" language="JavaScript1.2">
            if(DetectChromeForBasic()){
            writeNoScriptStyles();
            }

        </script><script type="text/javascript" language="JavaScript1.2">
            // Set reference to top level help frame
            //
            if(!DetectChromeForBasic()){
            javascriptTopicRedirect();
            }
        </script></head>
<body class="syn-arg" id="idee5ba678-0680-48f3-bf29-7936d87b447a">
<div id="bodycontent" class="BodyContent">
<script type="text/javascript" language="JavaScript1.2">
              var BC = new Array("TODO: Breadcrumb Title","title1","naV","naV","naV","naV","2");
          </script>
<noscript><iframe framespacing="0" marginheight="2px" frameborder="no" scrolling="no" src="../../MGC/html/noscript_header.htm" width="100%" height="100px;">xxx</iframe></noscript>
<script type="text/javascript" language="JavaScript1.2">
              if(DetectChromeForBasic()){
              if(!(top.inEclipse)){
              writeBasicHeader();
              }
              }
          </script>
<div id="BodyContent"><h1 class="title topictitle1">mti_ForceSignal()</h1>
<div class="body refbody CommandRefBody"><div class="abstract CommandRefAbstract"><span class="shortdesc">Forces a
value onto a VHDL signal.</span>
</div>
<div class="section Usages"><h2 class="title Subheading sectiontitle">Syntax</h2><div class="section UsageSet"><p class="lines UsageLine">error_code = mti_ForceSignal( signal_id, value_string, delay, force_type,  cancel_period, repeat_period )</p>
</div>
</div>
<div class="section Arguments"><h2 class="title Subheading sectiontitle">Arguments</h2><div class="section ArgumentSet">
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" class="table ArgumentTable" frame="void" border="0" rules="none"><colgroup><col style="width:1.774in" /><col style="width:1.822in" /><col style="width:2.780in" /></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry row-nocellborder default-entry" style="vertical-align:top;" id="d5289e159"><p class="p">Name</p>
</th>
<th class="entry row-nocellborder default-entry" style="vertical-align:top;" id="d5289e166"><p class="p">Type</p>
</th>
<th class="entry row-nocellborder default-entry" style="vertical-align:top;" id="d5289e169"><p class="p">Description</p>
</th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e159 "><p class="p">signal_id</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e166 "><p class="p">mtiSignalIdT</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e169 "><p class="p">A handle to the VHDL
signal to be forced</p>
</td>
</tr>
<tr class="row"><td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e159 "><p class="p">value_string</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e166 "><p class="p">char *</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e169 "><p class="p">The value to be forced
specified as a string in the same format as would be provided to
the simulator's force command</p>
</td>
</tr>
<tr class="row"><td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e159 "><p class="p">delay</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e166 "><p class="p">mtiDelayT</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e169 "><p class="p">The time at which the
force is to be applied relative to the current time; specified in
current simulator resolution units</p>
</td>
</tr>
<tr class="row"><td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e159 "><p class="p">force_type</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e166 "><p class="p">mtiForceTypeT</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e169 "><p class="p">Indicates whether the
force is to freeze, drive, deposit, or use the default force type</p>
</td>
</tr>
<tr class="row"><td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e159 "><p class="p">cancel_period</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e166 "><p class="p">mtiInt32T</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e169 "><p class="p">If non-negative, specifies
the period after which the force is canceled; specified in current
simulator resolution units</p>
</td>
</tr>
<tr class="row"><td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e159 "><p class="p">repeat_period</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e166 "><p class="p">mtiInt32T</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e169 "><p class="p">If non-negative, specifies
the period in which the force is repeated; specified in current
simulator resolution units</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="section ReturnedValues"><h2 class="title Subheading sectiontitle">Return Values</h2>
<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="idee5ba678-0680-48f3-bf29-7936d87b447a__id008f4f8c-0a76-4029-9ef2-f5225186d668" class="table" frame="void" border="0" rules="none"><colgroup><col style="width:1.382in" /><col style="width:1.430in" /><col style="width:2.388in" /></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry nocellnorowborder default-entry" style="vertical-align:top;" id="d5289e242"><p class="p">Name</p>
</th>
<th class="entry nocellnorowborder default-entry" style="vertical-align:top;" id="d5289e245"><p class="p">Type</p>
</th>
<th class="entry nocellnorowborder default-entry" style="vertical-align:top;" id="d5289e248"><p class="p">Description</p>
</th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e242 "><p class="p">error_code</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e245 "><p class="p">int</p>
</td>
<td class="entry nocellnorowborder default-entry" style="vertical-align:top;" headers="d5289e248 "><p class="p">1 if successful; 0 if
there is an error</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section Descriptions"><h2 class="title Subheading sectiontitle">Description</h2><p class="p">mti_ForceSignal()
forces the specified VHDL signal to the specified value using the specified
force type and an optional delay, cancel period, and repeat period.
The value must be specified in a string in the same format as would
be provided to the simulator's force command, and the restrictions
on the type of the value are the same as for the force command (refer
to the Command Reference Manual for details).</p>
<p class="p">If the delay parameter is non-negative,
then the delay specifies the time at which the force is to be applied
relative to the current time. If the delay parameter is negative,
then the force is applied immediately.</p>
<p class="p">If the cancel_period parameter
is non-negative, then the force is canceled after the specified
period. If the cancel_period parameter is negative, then the force
is not automatically canceled.</p>
<p class="p">If the repeat_period parameter
is non-negative, then the force is repeated for the specified period.
If the repeat_period parameter is negative, then the force is not
automatically repeated.</p>
<p class="p">To force records or arrays that
are not one-dimensional arrays of character enumerations, use <a class="xref fm:HeadingOnly" href="Command_MtiGetsignalsubelements_id1c9db5a2.html#id1c9db5a2-fff0-497f-b8bf-50ed5a09c6dc__Command_MtiGetsignalsubelements_id1c9db5a2.xml#id1c9db5a2-fff0-497f-b8bf-50ed5a09c6dc" title="Gets the subelements of a composite signal.">mti_GetSignalSubelements()</a> to get a handle to each element
and force each element individually.</p>
<p class="p">mti_ForceSignal() cannot force
a port if the port has values coming into it from a higher level
or if the port has a conversion function on it (although in some
cases you might be able to force the port using the MTI_FORCE_DRIVE
force type with mti_ForceSignal()).</p>
</div>
<div class="section Examples"><h2 class="title Subheading sectiontitle">Examples</h2><div class="section Subsection" id="idee5ba678-0680-48f3-bf29-7936d87b447a__ida2a4bb1f-77c7-464a-989b-0e81a22a8b31"><h2 class="title Subheading sectiontitle">FLI code</h2><pre class="pre codeblock"><code><span class="ph FontProperty P9">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#ifndef WIN32
#include &lt;unistd.h&gt;
#endif

#include &lt;mti.h&gt;

typedef struct signalInfoT_tag {
  struct signalInfoT_tag * next;
  struct signalInfoT_tag * child;
  char                   * name;
  void                   * last_value;
  mtiSignalIdT             sigid;
  mtiTypeIdT               typeid;
  mtiTypeKindT             typekind;
  mtiDirectionT            direction;
  char                     granulate;
} signalInfoT;

typedef struct {
  signalInfoT     * sig_info;         /* List of signals.             */
  mtiProcessIdT     proc;             /* Test process id.             */
  int               state;            /* Current state of test.       */
} instanceInfoT;

static void forceSignal(
  mtiSignalIdT sigid,
  mtiTypeIdT   sigtypeid,
  mtiTypeKindT sigtypekind,
  int          state
)
{
  int           i;
  int           result = 1;
  mtiSignalIdT *elem_list;
  mtiSignalIdT  elem_sigid;
  mtiTypeIdT    elem_typeid;

  switch ( sigtypekind ) {
   case MTI_TYPE_SCALAR:
    switch ( state ) {
     case 0:
      result = mti_ForceSignal(sigid, "42", -1, MTI_FORCE_FREEZE, -1, -1);
      break;
     case 2:
      result = mti_ForceSignal(sigid, "120", 1, MTI_FORCE_FREEZE, 7, -1);
      break;
     case 4:
      result = mti_ForceSignal(sigid, "777", -1, MTI_FORCE_DEPOSIT, -1, 2);
      break;
     }
     break;
   case MTI_TYPE_ARRAY:
    elem_typeid = mti_GetArrayElementType( sigtypeid );
    if ( mti_GetTypeKind( elem_typeid ) == MTI_TYPE_ENUM ) {
      /* NOTE: ASSUMING ARRAY OF LENGTH 4 ! */
     if ( mti_TickLength( elem_typeid ) == 9 ) {  /* ASSUME std_logic */
      switch ( state ) {
       case 0:
        result = mti_ForceSignal( sigid, "ZW1H", -1,
                                MTI_FORCE_FREEZE, -1, -1 );
        break;
       case 2:
        result = mti_ForceSignal( sigid, "LLLL", 1,
                                MTI_FORCE_FREEZE, 7, -1 );
        break;
       case 4:
        result = mti_ForceSignal( sigid, "1-1-", -1,
                                MTI_FORCE_DEPOSIT, -1, 2 );
        break;
      }
     } else {  /* ASSUME bit */
      switch ( state ) {
       case 0:
        result = mti_ForceSignal( sigid, "0011", -1,
                                MTI_FORCE_FREEZE, -1, -1 );
        break;
       case 2:
        result = mti_ForceSignal( sigid, "1000", 1,
                                MTI_FORCE_FREEZE, 7, -1 );
        break;
       case 4:
        result = mti_ForceSignal( sigid, "0010", -1,
                                MTI_FORCE_DEPOSIT, -1, 2 );
        break;
      }
     }
    } else {
     elem_list = mti_GetSignalSubelements( sigid, 0 );
     for ( i = 0; i &lt; mti_TickLength( sigtypeid ); i++ ) {
      elem_sigid  = elem_list[i];
      elem_typeid = mti_GetSignalType( elem_sigid );
      forceSignal( elem_sigid, elem_typeid,
                  mti_GetTypeKind( elem_typeid ), state );
      }
      mti_VsimFree( elem_list );
    }
    break;
   case MTI_TYPE_RECORD:
    elem_list = mti_GetSignalSubelements( sigid, 0 );
    for ( i = 0; i &lt; mti_GetNumRecordElements( sigtypeid ); i++ ) {
     elem_sigid  = elem_list[i];
     elem_typeid = mti_GetSignalType( elem_sigid );
     forceSignal( elem_sigid, elem_typeid,
                 mti_GetTypeKind( elem_typeid ), state );
     }
     mti_VsimFree( elem_list );
     break; 
   case MTI_TYPE_ENUM:
    if ( mti_TickLength( sigtypeid ) == 9 ) {   /* ASSUME std_logic */
     switch ( state ) {
      case 0:
       result = mti_ForceSignal( sigid, "'W'", -1,
                                MTI_FORCE_FREEZE, -1, -1 );
       break;
      case 2:
       result = mti_ForceSignal( sigid, "'0'", 1,
                                MTI_FORCE_FREEZE, 7, -1 );
       break;
      case 4:
       result = mti_ForceSignal( sigid, "'H'", -1,
                                MTI_FORCE_DEPOSIT, -1, 2 );
       break;
     }
    } else {
     switch ( state ) {  /* ASSUME bit */ 
      case 0:
       result = mti_ForceSignal( sigid, "0", -1,
                                MTI_FORCE_FREEZE, -1, -1 );
       break;
      case 2:
       result = mti_ForceSignal( sigid, "1", 1,
                                MTI_FORCE_FREEZE, 7, -1 );
       break;
      case 4:
       result = mti_ForceSignal( sigid, "0", -1,
                                MTI_FORCE_DEPOSIT, -1, 2 );
       break;
     }
    }
    break;
   default:
    break;
  }
  if ( ! result ) {
   fprintf( stderr, "Error in signal force.\n" );
  }
}

static void releaseSignal(
  mtiSignalIdT sigid,
  mtiTypeIdT   sigtypeid,
  mtiTypeKindT sigtypekind
)
{
  int           i;
  mtiSignalIdT *elem_list;
  mtiSignalIdT  elem_sigid;
  mtiTypeIdT    elem_typeid;

  switch ( sigtypekind ) {
   case MTI_TYPE_SCALAR:
   case MTI_TYPE_ENUM:
   case MTI_TYPE_TIME:
    if ( ! mti_ReleaseSignal( sigid ) ) {
     fprintf( stderr, "Error in signal release.\n" );
    }
    break;
   case MTI_TYPE_ARRAY:
    elem_typeid = mti_GetArrayElementType( sigtypeid );
    if ( mti_GetTypeKind( elem_typeid ) == MTI_TYPE_ENUM ) {
     if ( ! mti_ReleaseSignal( sigid ) ) {
      fprintf( stderr, "Error in signal release.\n" );
     }
    } else {
     elem_list = mti_GetSignalSubelements( sigid, 0 );
     for ( i = 0; i &lt; mti_TickLength( sigtypeid ); i++ ) {
      elem_sigid  = elem_list[i];
      elem_typeid = mti_GetSignalType( elem_sigid );
      releaseSignal( elem_sigid, elem_typeid,
                    mti_GetTypeKind( elem_typeid ) );
     }
     mti_VsimFree( elem_list );
    }
    break;
   case MTI_TYPE_RECORD:
    elem_list = mti_GetSignalSubelements( sigid, 0 );
    for ( i = 0; i &lt; mti_GetNumRecordElements( sigtypeid ); i++ ) {
     elem_sigid  = elem_list[i];
     elem_typeid = mti_GetSignalType( elem_sigid );
     releaseSignal( elem_sigid, elem_typeid,
                   mti_GetTypeKind( elem_typeid ) );
    }
    mti_VsimFree( elem_list );
    break;
   default:
    break;
  }
}

static void testForce( void *inst_info )
{
  instanceInfoT *inst_data = (instanceInfoT *)inst_info;
  signalInfoT   *siginfo;

  switch ( inst_data-&gt;state ) {
   case 0:
   case 2:
   case 4:
    for (siginfo = inst_data-&gt;sig_info; siginfo; siginfo = siginfo-&gt;next) {
     forceSignal( siginfo-&gt;sigid, siginfo-&gt;typeid,
                 siginfo-&gt;typekind, inst_data-&gt;state );
    }
    break;
   case 1:
   case 3:
   case 5:
    for (siginfo = inst_data-&gt;sig_info; siginfo; siginfo = siginfo-&gt;next) {
     releaseSignal( siginfo-&gt;sigid, siginfo-&gt;typeid, siginfo-&gt;typekind );
    }
    break;
   default:
    break;
  }

  inst_data-&gt;state++;
  mti_ScheduleWakeup( inst_data-&gt;proc, 10 );
}

static signalInfoT * setupSignal( mtiSignalIdT sigid )
{
  signalInfoT * siginfo;

  siginfo = (signalInfoT *) mti_Malloc( sizeof(signalInfoT) );
  siginfo-&gt;sigid       = sigid;
  siginfo-&gt;name        = mti_GetSignalNameIndirect( sigid, 0, 0 );
  siginfo-&gt;typeid      = mti_GetSignalType( sigid );
  siginfo-&gt;typekind    = mti_GetTypeKind( siginfo-&gt;typeid );
  siginfo-&gt;direction   = mti_GetSignalMode( sigid );
  siginfo-&gt;last_value  = mti_GetSignalValueIndirect( sigid, 0 );
  siginfo-&gt;child       = 0;
  siginfo-&gt;next        = 0;

  /* For records and arrays of composites, we want to set/drive
  * values at the subelement level.  For scalars and arrays of
  * scalars, we want to set/drive values at the top level.
  */
  switch ( siginfo-&gt;typekind ) { 
   case MTI_TYPE_ARRAY:
    switch( mti_GetTypeKind(mti_GetArrayElementType(siginfo-&gt;typeid)) ) {
     case MTI_TYPE_ARRAY:
     case MTI_TYPE_RECORD:
      siginfo-&gt;granulate = 1;
      break;
     default:
      siginfo-&gt;granulate = 0;
      break;
    }
    break;
   case MTI_TYPE_RECORD:
    siginfo-&gt;granulate = 1;
    break;
   default:
    siginfo-&gt;granulate = 0;
    break;
  }

  if ( siginfo-&gt;granulate ) {
    signalInfoT  * eleminfo;
    signalInfoT  * currinfo;
    int            i;
    mtiSignalIdT * subelem;

    subelem = mti_GetSignalSubelements( siginfo-&gt;sigid, 0 );
    for ( i = 0; i &lt; mti_TickLength(siginfo-&gt;typeid); i++ ) {
     eleminfo = setupSignal( subelem[i] );
     if ( siginfo-&gt;child == 0 ) {
      siginfo-&gt;child = eleminfo;
     } else {
      currinfo-&gt;next = eleminfo;
     }
     currinfo = eleminfo;
    }
    mti_VsimFree( subelem );
  }

  return( siginfo );
}

static void initInstance( void * param )
{
  instanceInfoT * inst_data;
  mtiRegionIdT    region;
  mtiSignalIdT    sigid;
  signalInfoT   * curr_info;
  signalInfoT   * siginfo;

  inst_data           = mti_Malloc( sizeof(instanceInfoT) );
  inst_data-&gt;sig_info = 0;
  inst_data-&gt;state    = 0;
  region              = mti_GetTopRegion();

  for (sigid = mti_FirstSignal( region ); sigid; sigid = mti_NextSignal()) {
   siginfo = setupSignal( sigid );
   if ( inst_data-&gt;sig_info == 0 ) {
    inst_data-&gt;sig_info = siginfo;
   }
   else {
    curr_info-&gt;next = siginfo;
   }
    curr_info = siginfo;
  }

  inst_data-&gt;proc = mti_CreateProcess( "Test Process", testForce,
                                      (void *)inst_data );
  mti_ScheduleWakeup( inst_data-&gt;proc, 11 );
}

void initForeign(
  mtiRegionIdT       region,   /* The ID of the region in which this     */
                               /* foreign architecture is instantiated.  */
  char              *param,    /* The last part of the string in the     */
                               /* foreign attribute.                     */
  mtiInterfaceListT *generics, /* A list of generics for the foreign model.*/
  mtiInterfaceListT *ports     /* A list of ports for the foreign model.   */
)
{
  mti_AddLoadDoneCB( initInstance, 0 );
}</span></code></pre></div>
<div class="section Subsection" id="idee5ba678-0680-48f3-bf29-7936d87b447a__id0b3239ea-7526-4b8b-a976-7bdb7eb19dd3"><h2 class="title Subheading sectiontitle">HDL code</h2><pre class="pre codeblock"><code>library ieee;
use ieee.std_logic_1164.all;

package typepkg is

  type bitarray  is array( 3 downto 0 ) of bit;
  type intarray  is array( 1 to 3 )     of integer;

  type rectype is record
    a : bit;
    b : integer;
    c : std_logic;
  end record;

end package typepkg;

-- -- --

entity for_model is
end for_model;

architecture a of for_model is
  attribute foreign of a : architecture is "initForeign for_model.sl;";
begin
end a;

-- -- --

library ieee;
use ieee.std_logic_1164.all;

use work.typepkg.all;

entity top is
end top;

architecture a of top is

  signal bitsig1      : bit       := '1';
  signal intsig1      : integer   := 21;
  signal stdlogicsig1 : std_logic := 'H';

  signal bitarr1      : bitarray  := "0110";
  signal stdlogicarr1 : std_logic_vector( 1 to 4 ) := "-X0U";
  signal intarr1      : intarray  := ( 10, 11, 12 );

  signal rec1         : rectype   := ( '0', 1, 'X' );

  component for_model
  end component;

  for all : for_model use entity work.for_model(a);

begin

  inst1 : for_model;

  bitsig1      &lt;= not bitsig1 after 5 ns;
  intsig1      &lt;= intsig1 + 1 after 5 ns;
  stdlogicsig1 &lt;= '-' after 5 ns when stdlogicsig1 = 'H' else
                  'U' after 5 ns when stdlogicsig1 = '-' else
                  'X' after 5 ns when stdlogicsig1 = 'U' else
                  '0' after 5 ns when stdlogicsig1 = 'X' else
                  '1' after 5 ns when stdlogicsig1 = '0' else
                  'Z' after 5 ns when stdlogicsig1 = '1' else
                  'W' after 5 ns when stdlogicsig1 = 'Z' else
                  'L' after 5 ns when stdlogicsig1 = 'W' else
                  'H' after 5 ns;

bitarr1           &lt;= not bitarr1 after 5 ns;

intarr1(1)        &lt;= intarr1(1) + 1 after 5 ns;
intarr1(2)        &lt;= intarr1(2) + 1 after 5 ns;
intarr1(3)        &lt;= intarr1(3) + 1 after 5 ns;

stdlogicarr1(1) &lt;= '-' after 5 ns when stdlogicarr1(1) = 'H' else
                  'U' after 5 ns when stdlogicarr1(1) = '-' else
                  'X' after 5 ns when stdlogicarr1(1) = 'U' else
                  '0' after 5 ns when stdlogicarr1(1) = 'X' else
                  '1' after 5 ns when stdlogicarr1(1) = '0' else
                  'Z' after 5 ns when stdlogicarr1(1) = '1' else
                  'W' after 5 ns when stdlogicarr1(1) = 'Z' else
                  'L' after 5 ns when stdlogicarr1(1) = 'W' else
                  'H' after 5 ns;

stdlogicarr1(2) &lt;= '-' after 5 ns when stdlogicarr1(2) = 'H' else
                  'U' after 5 ns when stdlogicarr1(2) = '-' else
                  'X' after 5 ns when stdlogicarr1(2) = 'U' else
                  '0' after 5 ns when stdlogicarr1(2) = 'X' else
                  '1' after 5 ns when stdlogicarr1(2) = '0' else
                  'Z' after 5 ns when stdlogicarr1(2) = '1' else
                  'W' after 5 ns when stdlogicarr1(2) = 'Z' else
                  'L' after 5 ns when stdlogicarr1(2) = 'W' else
                  'H' after 5 ns;

stdlogicarr1(3) &lt;= '-' after 5 ns when stdlogicarr1(3) = 'H' else
                  'U' after 5 ns when stdlogicarr1(3) = '-' else
                  'X' after 5 ns when stdlogicarr1(3) = 'U' else
                  '0' after 5 ns when stdlogicarr1(3) = 'X' else
                  '1' after 5 ns when stdlogicarr1(3) = '0' else
                  'Z' after 5 ns when stdlogicarr1(3) = '1' else
                  'W' after 5 ns when stdlogicarr1(3) = 'Z' else
                  'L' after 5 ns when stdlogicarr1(3) = 'W' else
                  'H' after 5 ns;

stdlogicarr1(4) &lt;= '-' after 5 ns when stdlogicarr1(4) = 'H' else
                  'U' after 5 ns when stdlogicarr1(4) = '-' else
                  'X' after 5 ns when stdlogicarr1(4) = 'U' else
                  '0' after 5 ns when stdlogicarr1(4) = 'X' else
                  '1' after 5 ns when stdlogicarr1(4) = '0' else
                  'Z' after 5 ns when stdlogicarr1(4) = '1' else
                  'W' after 5 ns when stdlogicarr1(4) = 'Z' else
                  'L' after 5 ns when stdlogicarr1(4) = 'W' else
                  'H' after 5 ns;

rec1.a &lt;= not rec1.a after 5 ns;
rec1.b &lt;= rec1.b + 1 after 5 ns;
rec1.c &lt;= '-' after 5 ns when rec1.c = 'H' else
          'U' after 5 ns when rec1.c = '-' else
          'X' after 5 ns when rec1.c = 'U' else
          '0' after 5 ns when rec1.c = 'X' else
          '1' after 5 ns when rec1.c = '0' else
          'Z' after 5 ns when rec1.c = '1' else
          'W' after 5 ns when rec1.c = 'Z' else
          'L' after 5 ns when rec1.c = 'W' else
          'H' after 5 ns;

end a;</code></pre></div>
<div class="section Subsection" id="idee5ba678-0680-48f3-bf29-7936d87b447a__id6350cce7-6539-40f3-831a-c33b8c0f37e1"><h2 class="title Subheading sectiontitle">Simulation output</h2><pre class="pre codeblock"><code>% vsim -c top
Reading .../modeltech/tcl/vsim/pref.tcl 

# 5.4b

# vsim -c top 
# Loading .../modeltech/sunos5/../std.standard
# Loading .../modeltech/sunos5/../ieee.std_logic_1164(body)
# Loading work.typepkg
# Loading work.top(a)
# Loading work.for_model(a)
# Loading ./for_model.sl
VSIM 1&gt; add list -w 1 /top/bitsig1
VSIM 2&gt; add list -w 3 /top/intsig1
VSIM 3&gt; add list -w 1 /top/stdlogicsig1
VSIM 4&gt; add list -w 4 /top/bitarr1
VSIM 5&gt; add list -w 4 /top/stdlogicarr1
VSIM 6&gt; add list -w 15 /top/intarr1
VSIM 7&gt; add list -w 10 /top/rec1
VSIM 8&gt; run 70
VSIM 9&gt; write list list.out
VSIM 10&gt; quit -f
% cat list.out
 ns       /top/bitsig1                    /top/intarr1  /top/rec1
  delta       /top/intsig1
           /top/stdlogicsig1
                     /top/bitarr1
                     /top/stdlogicarr1
  0  +0              1  21 H 0110 -X0U      {10 11 12}    {0 1 X} 
  5  +0              0  22 - 1001 U01X      {11 12 13}    {1 2 0} 
 10  +0              1  23 U 0110 X1Z0      {12 13 14}    {0 3 1} 
 11  +0              0  42 W 0011 ZW1H      {42 42 42}   {0 42 W} 
 21  +1              1  43 L 1100 WLZ-      {43 43 43}   {1 43 L} 
 26  +0              0  44 H 0011 LHWU      {44 44 44}   {0 44 H} 
 31  +0              1  45 - 1100 H-LX      {45 45 45}   {1 45 -} 
 32  +0              1 120 0 1000 LLLL   {120 120 120}  {1 120 0} 
 38  +1              0 121 1 0111 HHHH   {121 121 121}  {0 121 1} 
 43  +0              1 122 Z 1000 ----   {122 122 122}  {1 122 Z} 
 48  +0              0 123 W 0111 UUUU   {123 123 123}  {0 123 W} 
 51  +0              0 777 H 0010 1-1-   {777 777 777}  {0 777 H} 
 53  +0              0 777 H 0010 1-1-   {777 777 777}  {0 777 H} 
 56  +0              0 778 - 1101 ZUZU   {778 778 778}  {0 778 -} 
 57  +0              0 777 H 0010 1-1-   {777 777 777}  {0 777 H} 
 58  +0              1 777 H 0010 1-1-   {777 777 777}  {1 777 H} 
 59  +0              0 777 H 0010 1-1-   {777 777 777}  {0 777 H} 
 61  +1              1 778 - 1101 ZUZU   {778 778 778}  {1 778 -} 
 66  +0              0 779 U 0010 WXWX   {779 779 779}  {0 779 U} </code></pre></div>
</div>
</div>
<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent Topic:</strong> <a class="link" href="../topics/MGCChap_FliFunctionDefinitions_id33771d04.html" title="This chapter describes the FLI functions in detail, explaining their purpose, syntax, and usage.">FLI Function Definitions</a></div>
</div>

<div class="linklist linklist relinfo"><strong>Related Topics</strong><br />

<div><a class="link" href="../topics/Command_MtiVsimfree_id7390869b.html#id7390869b-5e7c-410d-bdaa-025b0b0dae95__" title="Frees simulator-allocated memory.">mti_VsimFree()</a></div>
<div><a class="link" href="../topics/Command_MtiTicklength_id7a711375.html#id7a711375-2ca8-42eb-b60f-e7af9c58a751__" title="Gets the length of a type.">mti_TickLength()</a></div></div>
</div></div>
</div>
<!--BeginFooterContent--><div class="BlankFooter" id="BlankFooter"> </div><div class="Footer" id="Footer"> </div><script type="text/javascript"><!--
                PDFLinkTitle = "InfoHub.Help"
                DocHandle = "fli"
                DocTitle = "Foreign Language Interface Manual"
                PageTitle = "mti_ForceSignal()"
                Copyright = "2020"
                ThisTopic = "PointingtoaCommoncustomerjsFile";
                CurrentFile = "topics/Command_MtiForcesignal_idee5ba678.html"
                CurrentFileID = "3";
                topicFooter();
            --></script><noscript><p class="MGCFooter">Foreign Language Interface Manual Software Version 2020.4<br />Unpublished work. © Siemens 2020<br /><a href="../../mgc_html_help/nsmgchelp.htm" target="_blank">Browser Requirements</a></p></noscript></body>
</html>