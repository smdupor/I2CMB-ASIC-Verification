<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta name="copyright" content="(C) Copyright 2020" />
<meta name="DC.rights.owner" content="(C) Copyright 2020" />
<meta name="DC.Type" content="ContainerTopic" />
<meta name="DC.Title" content="Inheritance, Overrides, and Search Order" />
<meta name="abstract" content="When considering the configuration of most regression suites, there is usually some degree of repetition. If, for example, 100 tests all require the same simulation commands with some minor variation, it would be a poor system that forced the user to specify the redundant information 100 times, once per test." />
<meta name="description" content="When considering the configuration of most regression suites, there is usually some degree of repetition. If, for example, 100 tests all require the same simulation commands with some minor variation, it would be a poor system that forced the user to specify the redundant information 100 times, once per test." />
<meta name="prodname" content="Verification Run Manager User Guide" />
<meta name="version" content="2014.06" />
<meta name="release" content="v2014.06" />
<meta name="series" content="mgc_ih" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Creator" content="Mentor Graphics Corporation" />
<meta name="DC.Publisher" content="Mentor Graphics Corporation 10 24 2014 10 24 2014 Fresh off the boat." />
<meta name="DC.Date.Created" content="0000-00-00" />
<meta name="DC.Date.Modified" content="2020-07-10" />
<meta name="VariantPrefix" content="none" />
<meta name="Tier" content="1" />
<meta name="SubTitle" content="none" />
<meta name="SourceHandle" content="vrm_user" />
<meta name="SoftwareVersionNum" content="2020.4" />
<meta name="SoftwareRelease" content="none" />
<meta name="RevHist" content="5.3" />
<meta name="PublicationDate" content="none" />
<meta name="Platform" content="none" />
<meta name="PartNumber" content="none" />
<meta name="LicenseType" content="EULA" />
<meta name="InfoHubHandle" content="questa_sim_ih" />
<meta name="EclipsePluginName" content="none" />
<meta name="DraftDate" content="none" />
<meta name="Draft" content="none" />
<meta name="DocumentTitle" content="Questa® Verification Run Manager User Guide" />
<meta name="CSHelp" content="no" />
<meta name="CSDSearchKeywords" content="product.version.2020.4,doc.type.documentation.user,doc.type.documentation.ref,product.id.P10593," />
<meta name="Copyright" content="READONLY - Use: copyrfirst and copyrlast" />
<meta name="ConditionFiltering" content="XML" />
<meta name="ChecklinksRelease" content="mti2020" />
<meta name="BookcaseHandle" content="_bk_questa_sim" />
<meta name="Beta" content="none" />
<meta name="Alpha" content="none" />
<meta name="ActiveStatus" content="Active" />
<meta name="GenerateOnlyChangedTopics" content="none" />
<meta name="HighlightChanges" content="none" />
<meta name="HighlightColor" content="Pale Green" />
<meta name="IncludeInInventory" content="yes" />
<meta name="SourceEDDVersion" content="12.2.10" />
<meta name="DC.Format" content="XHTML" />
<meta name="DC.Identifier" content="id01f79c08-5fab-42f9-a986-e7565254673c" />
<link rel="stylesheet" type="text/css" href="../commonltr.css" />
<title>Inheritance, Overrides, and Search Order</title>
<link rel="stylesheet" href="../../MGC/styles/mgcdita-lang.css" type="text/css" /><noscript><link rel="StyleSheet" href="../../MGC/styles/body.css" type="text/css" /><link rel="StyleSheet" href="../../MGC/styles/catalog.css" type="text/css" /><link rel="StyleSheet" href="../../MGC/styles/document.css" type="text/css" /><link rel="stylesheet" href="../../MGC/styles/mgcdita-lang.css" type="text/css" /></noscript><meta name="mgc_html_doctitle" content="Inheritance, Overrides, and Search Order" />
<meta name="attributes" content="product.version.2020.4,doc.type.documentation.user,doc.type.documentation.ref,product.id.P10593," />
<meta name="TEMPLATEBASE" content="mgc_mgchelp_v4.2.009" />
<script type="text/javascript" language="JavaScript1.2" src="../../MGC/js/page.js"></script><script type="text/javascript" language="JavaScript1.2">
            if(DetectChromeForBasic()){
            writeNoScriptStyles();
            }

        </script><script type="text/javascript" language="JavaScript1.2">
            // Set reference to top level help frame
            //
            if(!DetectChromeForBasic()){
            javascriptTopicRedirect();
            }
        </script></head>
<body id="id01f79c08-5fab-42f9-a986-e7565254673c">
<div id="bodycontent" class="BodyContent">
<script type="text/javascript" language="JavaScript1.2">
              var BC = new Array("TODO: Breadcrumb Title","title1","naV","naV","naV","naV","2");
          </script>
<noscript><iframe framespacing="0" marginheight="2px" frameborder="no" scrolling="no" src="../../MGC/html/noscript_header.htm" width="100%" height="100px;">xxx</iframe></noscript>
<script type="text/javascript" language="JavaScript1.2">
              if(DetectChromeForBasic()){
              if(!(top.inEclipse)){
              writeBasicHeader();
              }
              }
          </script>
<div id="BodyContent"><h1 class="title topictitle1">Inheritance, Overrides, and Search Order</h1>
<div class="body MGCBody"><div class="abstract ContainerAbstract"><span class="shortdesc">When
considering the configuration of most regression suites, there is
usually some degree of repetition. If, for example, 100 tests all
require the same simulation commands with some minor variation,
it would be a poor system that forced the user to specify the redundant
information 100 times, once per test.</span>
</div>
<p class="p">Inheritance, combined with parameterization,
seeks to reduce the need for redundant data entry to zero (or as
close to zero as possible). In VRM, the following two forms of inheritance
are supported:</p>
<ul class="ul"><li class="li" id="id01f79c08-5fab-42f9-a986-e7565254673c__idc47ceedc-ad1f-42eb-b1b7-4375b96f585d"><p class="p">One is explicitly called out by
the user in the RMDB database.</p>
</li>
<li class="li" id="id01f79c08-5fab-42f9-a986-e7565254673c__id129ec554-c00f-47fd-9872-fffc908c9907"><p class="p">One is implicit in the membership
hierarchy of Groups and Tasks.</p>
</li>
</ul>
<p class="p">Both forms combine to provide the user
with the power to specify relatively complex regression suites with
a minimum of verbiage.</p>
<p class="p">The explicit form of inheritance is called
“base inheritance,” in that its role in the topology is similar
to base classes in an object-oriented language. Base inheritance
is supported for all three top-level elements: <span class="ph FontProperty emphasis">runnable</span>, <span class="ph FontProperty emphasis">method</span>,
and <span class="ph FontProperty emphasis">usertcl</span> elements.
To specify a base inheritance relationship, a <span class="ph FontProperty emphasis">base</span> attribute
is added to the element that seeks to inherit content from some
other element. The value of this <span class="ph FontProperty emphasis">base</span> attribute
is a list of names of elements of the same type, separated by spaces
and/or commas. The attribute is called <span class="ph FontProperty emphasis">base</span> to
indicate that the target of that relationship link serves as the
“base” on which the referring element is built. For example, consider
the following XML fragment:</p>
<pre class="pre codeblock leveled"><code>&lt;runnable name="bob"&gt;
	&lt;!-- bob's content --&gt;
&lt;/runnable&gt;
&lt;runnable name="fred" base="bob"&gt;
	&lt;!-- fred's content --&gt;
&lt;/runnable&gt;</code></pre><p class="p">In this example, the <span class="ph FontProperty emphasis">runnable</span> element
named <span class="ph FontProperty emphasis">fred</span> refers
to the <span class="ph FontProperty emphasis">runnable</span> element
named <span class="ph FontProperty emphasis">bob</span> via
the <span class="ph FontProperty emphasis">base</span> attribute.
The effect of this reference is that anything defined inside of
the <span class="ph FontProperty emphasis">runnable</span> element
named <span class="ph FontProperty emphasis">bob</span> (including
parameters, Action scripts, member lists, and so on) is treated
as if it were also defined inside of the <span class="ph FontProperty emphasis">runnable</span> element
named <span class="ph FontProperty emphasis">fred</span>,
unless the <span class="ph FontProperty emphasis">fred</span> <span class="ph FontProperty emphasis">runnable</span> element
already defines the construct in question. That is, if <span class="ph FontProperty emphasis">bob</span> defines
an <span class="ph FontProperty emphasis">execScript</span> but <span class="ph FontProperty emphasis">fred</span> does not,
then any search for an <span class="ph FontProperty emphasis">execScript</span> within <span class="ph FontProperty emphasis">fred</span> is
satisfied by the definition found within its base <span class="ph FontProperty emphasis">runnable</span> element (<span class="ph FontProperty emphasis">bob</span>).</p>
<p class="p">The implicit form of inheritance is called
“group inheritance,” in that it derives naturally from the arrangements
of Runnables into Groups. While base inheritance is a static property
of the configuration of the regression suite, group inheritance
can only be resolved at runtime, when the complete calling graph
of Groups and Tasks has been constructed. As mentioned above, a
Task can be a member of multiple Groups. When it is executed as
a member of one Group, its group inheritance chain is different
from that of the same Task when executed as a member of some other
Group. Group inheritance derives from membership in a Group, as
seen in the following example:</p>
<pre class="pre codeblock leveled"><code>&lt;runnable name="parent" type="group"&gt;
	&lt;members&gt;
		&lt;member&gt;child&lt;/member&gt;
		&lt;!-- other members --&gt;
	&lt;/members&gt;
	&lt;!-- other content --&gt;
&lt;/runnable&gt;
&lt;runnable name="child" type="task"&gt;
	&lt;!-- content --&gt;
&lt;/runnable&gt;</code></pre><p class="p">When the <span class="ph FontProperty emphasis">child</span> Task
is executed as part of the <span class="ph FontProperty emphasis">parent</span> Group,
its immediate group ancestor is the <span class="ph FontProperty emphasis">parent</span> Runnable.</p>
<p class="p">Since Groups can be members of other
Groups, the complete graph of a typical regression suite can be
rather complex, even if the configuration of that suite is not.
The complete sequence of events from the initial Group named on
the VRM command line to the leaf-level Task under consideration
is called the “calling chain” of the Task. At the very end of that
calling chain are the specific Action scripts invoked to carry out
the regression subtasks. In log messages and many other places within
VRM, these calling chains are displayed in a manner similar to paths
in a directory structure (in fact, they correspond directly to working directory
paths within the <span class="ph filepath">VRMDATA</span> directory tree). For
instance, the string:</p>
<pre class="pre codeblock leveled"><code>nightly/random/randtest1/execScript</code></pre><p class="p">refers to the <span class="ph FontProperty emphasis">execScript</span> Action
script of the <span class="ph FontProperty emphasis">randtest1</span> leaf-level
Task, that is called as a member of the <span class="ph FontProperty emphasis">random </span>Group,
which itself is called as a member of the <span class="ph FontProperty emphasis">nightly</span> Group,
which itself is invoked from the VRM command line. The Group that
is the immediate group ancestor of a given Task or Group is sometimes
called the “parent” Runnable of that Task or Group.</p>
<p class="p">In the case of base inheritance, the <span class="ph FontProperty emphasis">base</span> attribute
of the referring element can specify multiple base elements. This
could be looked upon as “multiple inheritance” except without most
of the baggage associated with that term in other programming languages.
The base element names can be separated by either whitespace or commas
(or both). Each base element name is made up of one or more non-space/non-comma characters
and is assumed to be the name of another element of the same type
as the referring element that is defined at the top-level of the
database.</p>
<p class="p">Following is an example that defines
two Tasks, each of which refers to two base Runnables:</p>
<pre class="pre codeblock leveled"><code>&lt;runnable name="base0" type="base"&gt;...&lt;/runnable&gt;
&lt;runnable name="base1" type="base"&gt;...&lt;/runnable&gt;
&lt;runnable name="base2" type="base"&gt;...&lt;/runnable&gt;
&lt;runnable name="task10" type="task" base="base1, base0"&gt;...&lt;/runnable&gt;
&lt;runnable name="task20" type="task" base="base2, base0"&gt;...&lt;/runnable&gt;</code></pre><p class="p">In this example, both Task Runnables
(<span class="ph FontProperty emphasis">task10</span> and <span class="ph FontProperty emphasis">task20</span>)
inherit the contents of the base Runnable <span class="ph FontProperty emphasis">base0</span> (to
the extent there is no overlapping content already defined in the <span class="ph FontProperty emphasis">task10</span> and <span class="ph FontProperty emphasis">task20</span> Runnables
themselves), whereas <span class="ph FontProperty emphasis">task10</span> also
inherits the contents of <span class="ph FontProperty emphasis">base1</span> and <span class="ph FontProperty emphasis">task20</span> also inherits
the contents of <span class="ph FontProperty emphasis">base2</span>.
The <span class="ph FontProperty emphasis">base1</span> and <span class="ph FontProperty emphasis">base2</span> Runnables
can serve as a sort of “categorization” scheme, each imparting some
content to other Runnables in their respective categories while
the <span class="ph FontProperty emphasis">base0</span> Runnable
lends content that is common across all (or at least a significant
number of) Runnables in the regression suite. This same functionality
applies to <span class="ph FontProperty emphasis">method</span> and <span class="ph FontProperty emphasis">usertcl</span> elements
as well.</p>
<p class="p">Where multiple base elements are specified
via the <span class="ph FontProperty emphasis">base</span> attribute,
the order in which the base elements are specified determines the
priority in the event similar content is defined in both base elements. The
search rules are as follows:</p>
<ol class="ol"><li class="li" id="id01f79c08-5fab-42f9-a986-e7565254673c__id11a8f9c0-e804-479b-8dc8-aeaedefe5dd4"><p class="p">Since VRM treats the contents of any
base element as though the contents were defined directly in the
referring element (except when overlapping local content exists),
VRM always follow the base inheritance chain before the group inheritance
chain (for <span class="ph FontProperty emphasis">runnable</span> elements,
that is the <span class="ph FontProperty emphasis">method</span> and <span class="ph FontProperty emphasis">usertcl</span> elements
do not support group inheritance).</p>
</li>
<li class="li" id="id01f79c08-5fab-42f9-a986-e7565254673c__id39129def-2251-4225-9fd8-fac6ea80f011"><p class="p">If there are multiple base elements,
then VRM completely analyzes the first base element before continuing
on to analyze the second. The order in which the element names appear
in the value of the <span class="ph FontProperty emphasis">base</span> attribute
of the referring element is the determining factor.</p>
</li>
<li class="li" id="id01f79c08-5fab-42f9-a986-e7565254673c__iddb60451a-8b6c-4306-94bc-c8fd650805de"><p class="p">In the case of <span class="ph FontProperty emphasis">runnable</span> elements,
if a search is not satisfied by any base Runnables on the base inheritance
chain, then the search continues with the immediate parent Runnable
on the group inheritance chain. </p>
</li>
</ol>
<p class="p">Note that this “multiple inheritance”
only applies to base inheritance. This is not an arbitrary rule
but the result of the definition of group inheritance. Unlike human
lineage, it only takes one Group Runnable to act as the “parent”
in kicking off the execution of a “child” Runnable from its member
list. Therefore, with respect to group inheritance, a Runnable only ever
has one immediate parent (but a potentially unlimited group inheritance
chain of ancestors from which to draw, of course).</p>
<p class="p">Both reconvergence and cyclicity (that
is, loops) in the base inheritance topology are allowed and handled
gracefully. Consider the famous “diamond” inheritance topology represented
by the following collection of Runnables:</p>
<pre class="pre codeblock leveled"><code>&lt;runnable type="task" name="top" base="left right"/&gt;
&lt;runnable type="base" name="left" base="bottom"/&gt;
&lt;runnable type="base" name="right" base="bottom"/&gt;
&lt;runnable type="base" name="bottom"/&gt;</code></pre><p class="p">In this case, the search order would
be <span class="ph FontProperty emphasis">top</span>, <span class="ph FontProperty emphasis">left</span>, <span class="ph FontProperty emphasis">bottom</span>,
then <span class="ph FontProperty emphasis">right</span>.
As odd as that may seem at first, the principle is that anything
defined in <span class="ph FontProperty emphasis">bottom</span> is
treated as if it were also defined in both <span class="ph FontProperty emphasis">left</span> and <span class="ph FontProperty emphasis">right</span> (per the
definition of base inheritance). So, when you search <span class="ph FontProperty emphasis">left</span> you
are implicitly searching <span class="ph FontProperty emphasis">bottom</span> as
well. The search order <span class="ph FontProperty emphasis">top</span>, <span class="ph FontProperty emphasis">left</span>, <span class="ph FontProperty emphasis">right</span>,
then <span class="ph FontProperty emphasis">bottom</span> requires a
special exception to be made in the case of multiple base elements.</p>
<p class="p">Both types of inheritance are recursive.
Group inheritance is implicitly so, tracing backward along the calling
chain leading to the Task or Action script in question. Base inheritance
is explicitly recursive by virtue of the fact that a “base” Runnable
can, itself, define another <span class="ph FontProperty emphasis">base</span> Runnable
via its own <span class="ph FontProperty emphasis">base</span> attribute.
When searching for a parameter or Action script definition or for
a Group membership list, the search follows the chain of base inheritance pointers
until the desired object is located or a <span class="ph FontProperty emphasis">runnable</span> element
without a <span class="ph FontProperty emphasis">base</span> attribute
is encountered.</p>
<p class="p">Cyclicity (loops) in the group inheritance
chain is illegal, as one cannot be one's own ancestor/descendant.
The base inheritance chain, however, ignores cyclicity. It is perfectly
legal for two elements to refer to each other as base elements as
follows:</p>
<pre class="pre codeblock leveled"><code>&lt;runnable type="task" name="left" base="right"/&gt;
&lt;runnable type="task" name="right" base="left"/&gt;</code></pre><p class="p">According to the definition of base inheritance,
anything defined in the base Runnable is considered to have been
defined in the referring Runnable. Therefore, barring any overlapping content,
what this does is define two Tasks which, for all practical purposes,
contain identical content. This is a contrived example to illustrate
a point and not something one might do intentionally. But the “diamond”
configuration above can occur in a complex configuration either
intentionally or inadvertently and is not an error in either case.
A simple cyclicity check, however, would be dumbfounded by the “diamond”
topology and the check would thus be very difficult to get right.
The base inheritance walking algorithm quietly terminates its traversal when
it detects any duplication with elements that have already been
examined (due to either cycles or reconvergent fanout in the base
inheritance topology) on the assumption that a second search of
that part of the inheritance graph will be as unfruitful the second
time around as it was the first. On the other hand, a cycle in the
group inheritance chain is squawked as an error and search traversal
terminates at the point where the cycle is detected in order to
avoid getting into an infinite search loop.</p>
<p class="p">It is also not an error for a group ancestor
to refer to a descendant or one of the descendant's base Runnables
(or vice-versa) via base inheritance. Any content search will still terminate
when it detects the duplication. In the case of a <span class="ph FontProperty emphasis">parent</span> and <span class="ph FontProperty emphasis">child</span> both referring
to the same base Runnable, the given base Runnable (and further
base Runnables along the base chain, if any) would have already
been searched as part of searching at the <span class="ph FontProperty emphasis">child</span> level
so there is no point searching again when we are at the <span class="ph FontProperty emphasis">parent</span> level
(the content of the Runnables is static once the RMDB database is
loaded). One possible application of this would be a base Runnable defining
a parameter that applies to all Groups starting with the letter
“a”. Since one could easily have a Group Runnable whose name starts
with an “a” and which contains a member Runnable whose name also
starts with “a”, these seemingly odd topological twists can easily occur
in a complex regression suite and are generally harmless.</p>
<p class="p">Note that a unique situation exists in
the case of <span class="ph FontProperty emphasis">runnable</span> elements,
since they support both base and group inheritance. Taking parameter
definitions as an example, the list of parameters “visible” from any
given Runnable can contain parameters defined in either base elements
or group ancestors. The question can arise as to which type of inheritance
should be used in what circumstances. Since a parent is shared by
all Runnables that are listed as members of that parent (which itself must
be a Group in order to be a parent), parameter definitions intended
to be visible to all members of a given Group (and any descendants
thereof) should be defined in the common Group shared by all the
Runnables who should have access to that parameter definition.</p>
<p class="p">On the other hand, parameter definitions
that should apply to multiple Runnables that do not share a common
ancestor (that is, Runnables that are scattered throughout the regression suite
hierarchy) should be defined in base Runnables and referred to via
the base inheritance mechanism. Parameters that should apply to
all Runnables can be referred to via a common base Runnable but
it would result in less configuration hassle to simply add that
parameter to the top-most Runnable of the regression suite topology
(which, in theory, should be visible from any Runnable in the suite,
barring more local definitions overshadowing the top-level definition). The
determination should be made on a case-by-case basis according to
the topology of the regression suite and the purpose of the parameter.
There is no fixed rule.</p>
<p class="p">Only the “content” of an element can
be inherited (that is, text content and/or other elements defined
within the element in question). Attributes of a given element (for
example, the <span class="ph FontProperty emphasis">type</span> attribute
of a runnable element) cannot be inherited by other elements. In
other words, if a Runnable of type <span class="ph FontProperty emphasis">task</span> points
to a Runnable of type <span class="ph FontProperty emphasis">group</span> as
its base, then the referring Runnable remains a <span class="ph FontProperty emphasis">task</span> Runnable.
However, any parameter or Action script elements defined within
the base <span class="ph FontProperty emphasis">group</span> Runnable
are treated as if they also occurred within the referring <span class="ph FontProperty emphasis">task</span> Runnable.</p>
<p class="p">Base inheritance includes all “content”
data in the base Runnable. Action scripts, parameters, and membership
lists can all be inherited from a base Runnable. However, only parameter
definitions or the <span class="ph FontProperty emphasis">execScript</span> definition
can be inherited via the group inheritance chain. The reasons for
this become clear after considering the execution model. Every parent
Group along the calling chain can potentially define its own <span class="ph FontProperty emphasis">preScript</span> and/or <span class="ph FontProperty emphasis">postScript</span>,
the absence of which must indicate the absence of any required action
at that juncture. The <span class="ph FontProperty emphasis">execScript</span>,
on the other hand, must be defined for each leaf-level Task and
cannot exist for Groups under the current execution model. Therefore,
it is safe to allow <span class="ph FontProperty emphasis">execScript</span> definitions
to be inherited from parent Groups while considering <span class="ph FontProperty emphasis">preScript</span> and <span class="ph FontProperty emphasis">postScript</span> definitions
to belong exclusively to the Group in which they are defined. As
for Group membership lists, there is no benefit to allowing group inheritance
of Group membership lists because in order for a Group to even have
a parent, it must be listed in the membership list of its parent
Group. Yet it cannot be listed as a member of itself without introducing
a cycle into the graph. Therefore, membership lists cannot be inherited
via the group inheritance chain.</p>
<p class="p">When searching for a parameter or an <span class="ph FontProperty emphasis">execScript</span> definition,
both dimensions of inheritance come into play. The chain of base
Runnables is queried first on the grounds that the contents of a
base Runnable are always treated as if those contents had been directly
specified in the referring Runnable. If the search remains unsatisfied after
walking the base inheritance chain(s), the search proceeds to the
immediate parent Runnable and continues from there (searching, as
always, any base Runnables of said parent before ascending to the
next parent).</p>
<p class="p">So one can see that even though the inheritance
mechanism is similar, the purpose of the two types of inheritance
differ in substantial ways. Base inheritance provides a static way
to collect the common semantic elements of multiple Groups or Tasks
into one place in order to save typing. The contents of a base Runnable
are considered part of the contents of the referring Runnable, except
only when the referring Runnable already defines that which is sought
after. Group inheritance provides a dynamic way to define common
behavior among the members (or descendants) of a particular Group
when (and only when) invoked within the context of that Group. It
allows a given Task or Group of Tasks to be run multiple times with
slight variations in behavior each time (for example, debug vs.
non-debug runs).</p>
<p class="p">As an example of how base inheritance
differs from group inheritance and why the latter is not sufficient
in itself, consider the case of several Groups, each representing
a different configuration of the design under verification. Let
us also say that you have defined a number of Tasks that each hold
nothing but a randomization seed. The list of seeds can be applied
against each of the design configurations simply by naming each
of the Tasks as a member of each of the Groups. But that would require
replicating the complete member list in each Group. Adding a new
Group or Task to this structure would require changes in several
places. Using base inheritance, the user can move the list of Tasks
(which, in fact, represents a list of seed values) to a common Runnable
definition and refer to it from each of the Groups. Adding a new
Group or Task now involves only one edit/addition to the RMDB database,
and then of course that new Group or Task will presumably be referred
to in one or more other Runnables.</p>
<p class="p">In the specific case of parameters, the
search also involves any -g or -G options that may have been specified
on the command line. The semantics of the -g and -G options are
detailed in “<a class="xref fm:HeadingAndPage" href="Contain_OverrideParameterValuesFromCommandLine_id249c2739.html#id249c2739-27ba-4247-97f8-3231fbbfa802__Contain_OverrideParameterValuesFromCommandLine_id249c2739.xml#id249c2739-27ba-4247-97f8-3231fbbfa802" title="VRM supports -g (parameter default) and -G (parameter override) options. These options have the same syntax and similar behavior to options of the same name in Questa vsim. The exact syntax of these options is as follows:">Override Parameter Values from Command Line</a>”. These options can provide
parameter values on specific Runnables (or specific calling chains)
that were not specified in the original RMDB database. In this case,
the search takes these into consideration at each Runnable it encounters.</p>
<p class="p">It might be useful at this point to give
a more explicit definition of what it means to say something is
“defined” in a given Runnable:</p>
<ul class="ul"><li class="li" id="id01f79c08-5fab-42f9-a986-e7565254673c__id0b80543d-1dee-4e0b-9794-e0b01e000344"><p class="p">A Group Runnable defines a member
list when a non-empty <span class="ph FontProperty emphasis">members</span> element
is present within the runnable element.</p>
</li>
<li class="li" id="id01f79c08-5fab-42f9-a986-e7565254673c__id657fe366-5f15-47a6-835e-c063712d4024"><p class="p">A Runnable defines an Action script
when an element corresponding to that script is present within the <span class="ph FontProperty emphasis">runnable</span> element
(even if that element is empty).</p>
</li>
<li class="li" id="id01f79c08-5fab-42f9-a986-e7565254673c__id3c0ce824-6642-4a07-b63c-f5b1c3af767b"><p class="p">A Runnable defines a parameter
of a given name when there exists a <span class="ph FontProperty emphasis">parameter </span>element
within the <span class="ph FontProperty emphasis">runnable </span>element
whose name matches that given name.</p>
</li>
</ul>
<p class="p">Note that an “empty” member list (that
is, a <span class="ph FontProperty emphasis">members</span> element
containing no child <span class="ph FontProperty emphasis">member</span> elements)
is not considered to define members. The empty <span class="ph FontProperty emphasis">members</span> element will
not cause the search for a membership list to terminate. Normally,
there is no legitimate reason for a Group to define a base Runnable
with members but to intentionally have no members itself.</p>
<p class="p">To create a group with no members, ignoring
any membership list defined as part of a base Runnable, simply define
an empty Task and make it a member of the Group that should behave
as if it has no members. Said Group will no longer be a “zero-member”
Group (it will be a Group with one member that does nothing, resulting
in pretty much the same effect). Also, it might be necessary to
add an empty <span class="ph FontProperty emphasis">execScript</span> element
to the empty Task Runnable in order to avoid the “no <span class="ph FontProperty emphasis">execScript</span>” warning.</p>
<p class="p">Note also that the search algorithm is
implemented in VRM itself and not in the VRM Database (RMDB) API.
The API returns results only for information defined directly within
the Runnable named as an argument of the API command.</p>
<p class="p">A special case exists when group inheritance
is applied to an <span class="ph FontProperty emphasis">usertcl</span> element.
Other elements (besides <span class="ph FontProperty emphasis">usertcl</span>)
are searched, not loaded. Suppose, for example, that you are looking
for a definition of the parameter <span class="ph FontProperty emphasis">fred</span> in
a base chain of <span class="ph FontProperty emphasis">runnable</span> elements.
If you do not find a matching parameter element in the first Runnable
searched, then you look at the base <span class="ph FontProperty emphasis">runnable</span> element(s).
If you do not find a definition for <span class="ph FontProperty emphasis">fred</span> there,
then you look for any base elements of those elements, and so on.
Once you find the data you are looking for (that is, a <span class="ph FontProperty emphasis">parameter</span> element
by the name of <span class="ph FontProperty emphasis">fred</span>),
the search stops and further base elements are not consulted.</p>
<p class="p">The <span class="ph FontProperty emphasis">usertcl</span> element,
on the other hand, gets loaded and not searched. So even though
there can be real TCL code defined in the first element you load,
that does not terminate the chain. Once the first element is loaded,
all the base elements on the base chain starting from that element
are consulted (and TCL code therein loaded) no matter what.</p>
<p class="p">The principle is that anything defined
in the base element is considered to have been defined in the referring
element. Therefore, if a <span class="ph FontProperty emphasis">usertcl</span> element
containing a <span class="ph FontProperty emphasis">base</span> attribute
is loaded, the base inheritance chain is followed in the same order
as with any other group inheritance chain and the TCL contents of
the base <span class="ph FontProperty emphasis">usertcl</span> elements
are also loaded. If, for example, a number of <span class="ph FontProperty emphasis">usertcl</span> elements
are to be selected for loading via a command-line option, then those
elements can be referred to as the <span class="ph FontProperty emphasis">base</span> elements
of a collecting <span class="ph FontProperty emphasis">usertcl</span> element
which is then, itself, called out on the command line. For example,
if you have the following <span class="ph FontProperty emphasis">usertcl</span> element
in the RMDB file:</p>
<pre class="pre codeblock leveled"><code>&lt;usertcl name="loadall" base="tcl1, tcl2, tcl3"/&gt;</code></pre><p class="p">then the command line:</p>
<pre class="pre codeblock leveled"><code>vrun -loadtcl @loadall ...</code></pre><p class="p">would cause the TCL contents of the <span class="ph FontProperty emphasis">usertcl</span> elements <span class="ph FontProperty emphasis">tcl1</span>, <span class="ph FontProperty emphasis">tcl2</span>,
and <span class="ph FontProperty emphasis">tcl3</span> to
all be loaded. This would occur despite the fact that the <span class="ph FontProperty emphasis">usertcl</span> element <span class="ph FontProperty emphasis">loadall</span> was,
itself, empty.</p>
<p class="p"><a class="xref fm:Table" href="#id01f79c08-5fab-42f9-a986-e7565254673c__id09007d52-9b74-4150-b2e2-ce29b24c1112">Table 1</a> summarizes the types of data (and meta-data)
items found in the RMDB database and which modes of inheritance
apply to each.</p>

<div class="tablenoborder"><table cellpadding="4" cellspacing="0" summary="" id="id01f79c08-5fab-42f9-a986-e7565254673c__id09007d52-9b74-4150-b2e2-ce29b24c1112" class="table" frame="border" border="1" rules="cols"><caption><span class="tablecap"><span class="table--title-label">Table 1. </span>RMDB Database Data Item Types</span></caption><colgroup><col style="width:0.961in" /><col style="width:2.877in" /><col style="width:0.942in" /><col style="width:1.069in" /></colgroup><thead class="thead" style="text-align:left;"><tr class="row"><th class="entry cellrowborder default-entry" style="vertical-align:top;" id="d33800e659"><p class="p">Element Base</p>
</th>
<th class="entry cellrowborder default-entry" style="vertical-align:top;" id="d33800e662"><p class="p">Data Item Group </p>
</th>
<th class="entry cellrowborder default-entry" style="vertical-align:top;" id="d33800e665"><p class="p">Inheritance from Base</p>
</th>
<th class="entry cellrowborder default-entry" style="vertical-align:top;" id="d33800e668"><p class="p">Inheritance from Group</p>
</th>
</tr>
</thead>
<tbody class="tbody"><tr class="row"><td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e659 "><p class="p">runnable</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e662 "><p class="p">parameters</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e665 "><p class="p">Yes</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e668 "><p class="p">Yes</p>
</td>
</tr>
<tr class="row"><td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e659 "><p class="p">runnable</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e662 "><p class="p">execScript</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e665 "><p class="p">Yes</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e668 "><p class="p">Yes</p>
</td>
</tr>
<tr class="row"><td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e659 "><p class="p">runnable</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e662 "><p class="p">preScript/postScript</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e665 "><p class="p">Yes</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e668 "><p class="p">No</p>
</td>
</tr>
<tr class="row"><td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e659 "><p class="p">runnable</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e662 "><p class="p">members list</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e665 "><p class="p">Yes</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e668 "><p class="p">No</p>
</td>
</tr>
<tr class="row"><td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e659 "><p class="p">method</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e662 "><p class="p">method command</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e665 "><p class="p">Yes</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e668 "><p class="p">No</p>
</td>
</tr>
<tr class="row"><td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e659 "><p class="p">usertcl</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e662 "><p class="p">TCL content</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e665 "><p class="p">Yes</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e668 "><p class="p">No</p>
</td>
</tr>
<tr class="row"><td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e659 "><p class="p">(all)</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e662 "><p class="p">attributes (note that
attribute meta-data is always specific to the XML element to which
is it attached)</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e665 "><p class="p">No</p>
</td>
<td class="entry cellrowborder default-entry" style="vertical-align:top;" headers="d33800e668 "><p class="p">No</p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="related-links TopicTOC levels:1">
<ul class="ullinks">
<li class="link ulchildlink"><strong><a href="../topics/Concept_ParameterInheritanceExample_idb52d5617.html" title="The following shows an example of base/group inheritance in the context of parameter expansion. ">Parameter Inheritance Example</a></strong></li>
<li class="link ulchildlink"><strong><a href="../topics/Concept_RunnableTypesInheritance_id38a746f4.html" title="From the point of view of base inheritance, all Runnable nodes are equivalent. A Group can refer to a Task as a base Runnable or vice-versa (since base inheritance is concerned only with content, not behavior). Data defined in the base Runnable is treated as if it is defined in the referring Runnable itself. While there is nothing preventing a base Runnable from participating in the execution graph of the regression suite, it is more common for Runnables used as a base for other Runnables to not be involved in the execution graph themselves. In such cases, it can be desirable to enforce this non-involvement so as to prevent inadvertent cycles in the graph. To mark a Runnable as non-participatory, set the value of the type attribute to base instead of task or group. If a base type Runnable is included in the membership list of a Group, then VRM outputs an error and ignore the base type Runnable. Note that this is similar to the “pure virtual base class” concept in C++ (a base that cannot, by itself, be instanced).">Runnable Types and Inheritance</a></strong></li>
<li class="link ulchildlink"><strong><a href="../topics/Contain_SearchOrderWhenExpandingParameterReference_id4a1838f4.html" title="There is, of course, no reason to expect that there would be only one definition for any given parameter, or that the parameter in question is defined in the same Runnable from which it is referenced. VRM parameters (and other element content) can be inherited from other Runnables. There is a priority order (that is, search order) used to determine the best definition to use in expanding a given parameter on behalf of a parameter reference found in a given Runnable. These rules are outlined below.">Search Order When Expanding a Parameter Reference</a></strong></li>
</ul>

<div class="familylinks">
<div class="parentlink"><strong>Parent Topic:</strong> <a class="link" href="../topics/MGCChap_ParametersParameterExpansion_id68da1844.html" title="Each Runnable definition (that is, each runnable element) can include a list of zero or more parameter element definitions. A parameter is nothing more than a name/value pair that allows multiple Tasks to share the same execution script (or multiple Groups to share the same Task) by providing unique per-Group or per-Task values to be used in the scripts.">Parameters and Parameter Expansion</a></div>
</div>
</div></div>
</div>
<!--BeginFooterContent--><div class="BlankFooter" id="BlankFooter"> </div><div class="Footer" id="Footer"> </div><script type="text/javascript"><!--
                PDFLinkTitle = "InfoHub.Help"
                DocHandle = "vrm_user"
                DocTitle = "Questa® Verification Run Manager User Guide"
                PageTitle = "Inheritance, Overrides, and Search Order"
                Copyright = "2020"
                ThisTopic = "PointingtoaCommoncustomerjsFile";
                CurrentFile = "topics/Contain_InheritanceOverridesSearchOrder_id01f79c08.html"
                CurrentFileID = "3";
                topicFooter();
            --></script><noscript><p class="MGCFooter">Questa® Verification Run Manager User Guide Software Version 2020.4<br />Unpublished work. © Siemens 2020<br /><a href="../../mgc_html_help/nsmgchelp.htm" target="_blank">Browser Requirements</a></p></noscript></body>
</html>