 <!-- WorkBook Path: C:\Users\turker\Desktop\verification-proj1\project_benches\proj_3\sim\i2cmb_test_plan.xls -->
 <!-- Date: 1/1/0001 5:58:07 PM -->
<Workbook>
	<Worksheet>
		<Table>
			 <!-- I2CMB Testplan -->
			<Row>
				<Cell>1</Cell>  <!-- # -->
				<Cell>Register Tests</Cell>  <!-- Section -->
				<Cell></Cell>  <!-- Description -->
				<Cell></Cell>  <!-- Link -->
				<Cell></Cell>  <!-- Type -->
				<Cell>1</Cell>  <!-- Weight -->
				<Cell>100</Cell>  <!-- Goal -->
			</Row>
			<Row>
				<Cell>1.1</Cell>
				<Cell>Register Cross-Checking</Cell>
				<Cell>Require that writes to one of three writeable registers does not alter values of other registers, except for commands which alter the FSM-States Register, and status response bits in the CMDR</Cell>
				<Cell>test_register_crosschecking</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>1.2</Cell>
				<Cell>Reg. Access Control</Cell>
				<Cell>Expect that writes to read-only regions of registers do not change the values stored at these read-only bits</Cell>
				<Cell>test_register_access_control</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>1.3</Cell>
				<Cell>Reg. Field Accuracy</Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>1.3.1</Cell>
				<Cell>CMDR[DONE]</Cell>
				<Cell>Expect DONE bit raised when DUT command operation completed</Cell>
				<Cell>assert_done_raised_on_complete</Cell>
				<Cell>Assertion</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>1.3.2</Cell>
				<Cell>CMDR[NACK]</Cell>
				<Cell>Expect NACK bit raised when no slave response to master request; else low</Cell>
				<Cell>assert_nacks_when_expected</Cell>
				<Cell>Assertion</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>1.4</Cell>
				<Cell>Default Register Values</Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>1.4.1</Cell>
				<Cell>CSR Defaults</Cell>
				<Cell>On a DUT &quot;soft reset&quot; with interrupt disabled (Disable-Enable) Expect CSR == 8&#39;b1000_0000, With Interrupt enabled CSR == 8&#39;b1100_0000</Cell>
				<Cell>assert_csr_enable_defaults</Cell>
				<Cell>Assertion</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>1.4.2</Cell>
				<Cell>DPR Default</Cell>
				<Cell>After &quot;soft reset&quot; expect DPR == 8&#39;h00</Cell>
				<Cell>assert_dpr_default_on_enable</Cell>
				<Cell>Assertion</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>1.4.3</Cell>
				<Cell>CMDR Default</Cell>
				<Cell>After &quot;soft reset&quot; expect CMDR == 8&#39;b1000_0000</Cell>
				<Cell>assert_cmdr_default_on_enable</Cell>
				<Cell>Assertion</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>1.4.4</Cell>
				<Cell>FSMR Default</Cell>
				<Cell>After &quot;soft reset&quot; expect FSMR == 8&#39;h00</Cell>
				<Cell>assert_fsmr_default_on_enable</Cell>
				<Cell>Assertion</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>1.5</Cell>
				<Cell>Require Interrupts from Regblock</Cell>
				<Cell>When enabled, Require interrupts to be raised by the regblock when DUT has completed operation. Directed and random testflows from the test_multi_bus group will all require an interrupt to be raised when DUT is reporting done.</Cell>
				<Cell>test_multi_bus_*</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>2</Cell>
				<Cell>Compulsory Tests</Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>2.1</Cell>
				<Cell>Base Single-Bus Test</Cell>
				<Cell>Expect completed transactions with single and multiple bytes,both read and write, with both start-stop and start-restart-stop conditions to complete successfully, with single bus configured to default Speed (100kHz). Use RANDOM addresses, data, message length(zero/single/multibyte) and operations types.</Cell>
				<Cell>test_single_bus_default_speed</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>2.2</Cell>
				<Cell>Base Multi-Bus Test</Cell>
				<Cell>Expect completed transactions on multiple busses with single and multiple bytes,both read and write, with both start-stop and start-restart-stop conditions to complete successfully, with each bus configured to default Speed (100kHz). Use RANDOM Bus Selection, addresses, data, message length(zero/single/multibyte), and operations types.</Cell>
				<Cell>test_multi_bus_default_speed</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>2.3</Cell>
				<Cell>Multi-Bus Max Speed Test</Cell>
				<Cell>Expect completed transactions on multiple busses with single and multiple bytes,both read and write, with both start-stop and start-restart-stop conditions to complete successfully, with each bus configured to Maximum Speed (100kHz). Use RANDOM Bus Selection, addresses, data,  message length(zero/single/multibyte), and operations types.</Cell>
				<Cell>test_multi_bus_max_speed</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>2.4</Cell>
				<Cell>Multi-Bus Varying Speeds Test</Cell>
				<Cell>Expect completed transactions on multiple busses with single and multiple bytes,both read and write, with both start-stop and start-restart-stop conditions to complete successfully, with busses configured to a range from (400kHz) to (10kHz) Use RANDOM Bus Selection, addresses, data,  message length(zero/single/multibyte), and operations types.</Cell>
				<Cell>test_multi_bus_ranged_speed</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>3</Cell>
				<Cell>Arbitration</Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>3.1</Cell>
				<Cell>Arbitration Lost (All Busses)</Cell>
				<Cell>In the presence of a simulated multi-master transmitting at the same time (BFM write 0, DUT write 1), expect DUT to lose arbitration. Require behavior across all available i2c busses.</Cell>
				<Cell>test_arbitration_lost_scenario</Cell>
				<Cell>test</Cell>
				<Cell>2</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>3.1.1</Cell>
				<Cell>CMDR[ARB_LOST]</Cell>
				<Cell>Require &quot;Arbitration Lost&quot; bit in the CMDR to rise when master has lost arbitration negotiation</Cell>
				<Cell>assert_require_arb_loss_bit</Cell>
				<Cell>Assertion</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>3.2</Cell>
				<Cell>Arbitration Won CMDR[ARB_LOST]</Cell>
				<Cell>In the presence of a real multi-master configuration, expect Arbitration lost bit of CMDR to be low upon arbitration win</Cell>
				<Cell>assert_arbitration_won</Cell>
				<Cell>Assertion</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>4</Cell>
				<Cell>Clock-Stretching and WB Waits</Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>4.1</Cell>
				<Cell>Slave-End Clock Stretching  (Any Bus)</Cell>
				<Cell>Expect transfers to complete when TB delays subsequent operations legally from the I2c-interface via I2c  Clock Stretching (scl held low at legal times (after receive address/data bit, after transmit ACK/NACK, Before transmit &quot;read&quot; data bit)</Cell>
				<Cell>clockstretch_cg::i2c_stretch_delay</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>4.2</Cell>
				<Cell>Slave-End Clock Stretching  (All Busses)</Cell>
				<Cell>Expect clockstretching to apply and work as described in 4.1, across all available busses</Cell>
				<Cell>clockstretch_cg::stretch_x_bus_sel</Cell>
				<Cell>Cross</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>4.3</Cell>
				<Cell>Master-End Upstream Delays</Cell>
				<Cell>Expect transfers to complete when TB delays operations on the WB end of the DUT, via stalling continued commands after a completed read or write. REQUIRE no extraneous starts/stops or clock cycles during these stalls.</Cell>
				<Cell>wb_transaction_cg::wb_stretch_delay</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>4.4</Cell>
				<Cell>Wait Commands</Cell>
				<Cell>Expect transfers to complete when explicit wait commands issues to DUT with subsequent operations</Cell>
				<Cell>wait_cg::explicit_wait_times</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>4.5</Cell>
				<Cell>Directed Clockstretching Test</Cell>
				<Cell>Initiate required clockstretched transfers to meet coverage in all coverpoints and crosses for Clockstretching group. Use randomized time quantities for clocks to be slowed. Require successful transfers in single, multi-byte, and bidirectional, in the presence of stretched clocks. Use RANDOM Bus Selection, addresses, data, and operations types. Use RANDOM CLOCKSTRETCH DURATIONS. Insert RANDOM WB-end delays. Insert RANDOM explicit WAIT commands via DUT. </Cell>
				<Cell>test_clockstretching</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>5</Cell>
				<Cell>Soft Resets and Interrupts</Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>5.1</Cell>
				<Cell>Intr-Intr Reset</Cell>
				<Cell>After an Enable-Transfers-Disable-Enable, with interrupts enabled for both enable commands, expect subsequent transfers to complete successfully, with interrupt signal being raised by DUT to signal done</Cell>
				<Cell>test_enable_disable_enable_intr_x_poll</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>5.2</Cell>
				<Cell>Intr-Poll Reset</Cell>
				<Cell>After an Enable-Transfers-Disable-Enable, with interrupts enabled for first command, and disabled for second &quot;enable&quot; command, expect subsequent transfers to complete successfully, WITHOUT Interrupt signal being raised by DUT to signal done</Cell>
				<Cell>test_enable_disable_enable_intr_x_poll</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>5.3</Cell>
				<Cell>Poll-Intr Reset</Cell>
				<Cell>After an Enable-Transfers-Disable-Enable, with interrupts DISabled for first command, and ENabled for second &quot;enable&quot; command, expect subsequent transfers to complete successfully, WITH Interrupt signal being raised by DUT to signal done</Cell>
				<Cell>test_enable_disable_enable_intr_x_poll</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>5.4</Cell>
				<Cell>Poll-Poll Reset</Cell>
				<Cell>After an Enable-Transfers-Disable-Enable, with interrupts DISabled for first command, and DISabled for second &quot;enable&quot; command, expect subsequent transfers to complete successfully, WITHOUT Interrupt signal being raised by DUT to signal done</Cell>
				<Cell>test_enable_disable_enable_intr_x_poll</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>6</Cell>
				<Cell>Hard Resets</Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>6.1</Cell>
				<Cell>Hard rst via rst signal between xfers</Cell>
				<Cell>When a 133ns reset is raised after a completed transfer, expect subsequent enable-transfer flows to complete successfully</Cell>
				<Cell>test_hard_reset_insertion</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>7</Cell>
				<Cell>FSM Testing</Cell>
				<Cell>Require that code coverage reports 100% FSM State and Transition arc coverage within DUT, for all DUT FSMs</Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>7.1</Cell>
				<Cell>Byte-Level FSM Coverage</Cell>
				<Cell>State and Transition coverage for i2cmb Byte-Level FSM</Cell>
				<Cell>/top/DUT/iicmb_m_inst0/mbyte_inst0/state</Cell>
				<Cell>FSM</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>7.2</Cell>
				<Cell>Bit-Level FSM Coverage</Cell>
				<Cell>State and Transition coverage for i2cmb Bit-Level FSM</Cell>
				<Cell>/top/DUT/iicmb_m_inst0/mbit_inst0/state</Cell>
				<Cell>FSM</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>7.3</Cell>
				<Cell>Bus Conditioner FSMs</Cell>
				<Cell>State and Transition Coverage for i2cmb Bus-Conditioner FSMs</Cell>
				<Cell>/top/DUT/iicmb_m_inst0/conditioner_mux_inst0/*</Cell>
				<Cell>FSM</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>8</Cell>
				<Cell>DUT Code Coverage</Cell>
				<Cell>RTL Core ALL stmt, brnch, fsm, trans, expr. Require that all DUT units have 100% statement coverage and 100% branch coverage.</Cell>
				<Cell>/top/DUT</Cell>
				<Cell>Instance</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>9</Cell>
				<Cell>I2C Protocol Testing</Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>9.1</Cell>
				<Cell>I2C Addresses</Cell>
				<Cell>Ensure all addresses have been selected and used for successful transfers</Cell>
				<Cell>i2c_transaction_cg::address</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>9.2</Cell>
				<Cell>I2C Data Values</Cell>
				<Cell>Ensure all possible data values have been selected and used for successful transfer</Cell>
				<Cell>i2c_transaction_cg::data</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>9.3</Cell>
				<Cell>I2C Bus Selection</Cell>
				<Cell>Ensure all available data busses have been properly tested</Cell>
				<Cell>i2c_transaction_cg::bus_sel</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>9.4</Cell>
				<Cell>I2C Operation Type</Cell>
				<Cell>Ensure both reads and writes are covered</Cell>
				<Cell>i2c_transaction_cg::operation</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>9.5</Cell>
				<Cell>I2C Message Size (Single and Multi-Byte)</Cell>
				<Cell>Ensure DUT properly handles Zero-data, single-byte, and multi-byte transactions</Cell>
				<Cell>i2c_transaction_cg::msg_size</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>9.6</Cell>
				<Cell>I2C START and RE-START</Cell>
				<Cell>Ensure that DUT properly handles both START (from idle) and RE-START (From transaction-in-progress) initiations of new transactions.</Cell>
				<Cell>predictor_cg::start_or_restart</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>9.7</Cell>
				<Cell>Operation Vs Msg Size</Cell>
				<Cell>Ensure that all message sizes are used in both I2C Read and Write transaction types</Cell>
				<Cell>i2c_transaction_cg::msg_size_x_operation</Cell>
				<Cell>Cross</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>9.8</Cell>
				<Cell>Operation Vs Data</Cell>
				<Cell>Ensure that all legal data values are covered across  both I2C Read and Write transaction types</Cell>
				<Cell>i2c_transaction_cg::operation_x_data</Cell>
				<Cell>Cross</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>9.9</Cell>
				<Cell>Operation  Vs Address</Cell>
				<Cell>Ensure that all valid address values are covered for  both I2C Read and Write transaction types</Cell>
				<Cell>i2c_transaction_cg::operation_x_address</Cell>
				<Cell>Cross</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>9.10</Cell>
				<Cell>Operation vs Start-Restart</Cell>
				<Cell>Ensure that start-restart conditions are covered for both read and write transaction types.</Cell>
				<Cell>predictor_cg::restart_x_operation</Cell>
				<Cell>Cross</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>10</Cell>
				<Cell>WB Protocol Testing</Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>10.1</Cell>
				<Cell>WB Command Coverage</Cell>
				<Cell>Ensure that all possible WB transactions and commands have been used as part of overall testplan</Cell>
				<Cell>wb_transaction_cg::cmd_type</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>10.2</Cell>
				<Cell>WB Register Coverage</Cell>
				<Cell>TODO TODO TODO</Cell>
				<Cell>wb_transaction_cg::reg_type</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>11</Cell>
				<Cell>Connected and Disconnected Slave</Cell>
				<Cell>Ensure NACKs are passed to WB interface when no slave response detected; otherwise, expect ACKS on WB-End</Cell>
				<Cell></Cell>
				<Cell></Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>11.1</Cell>
				<Cell>Config Slave Connected or Disconnected</Cell>
				<Cell>Expect NACK bit raised when no slave response to master request</Cell>
				<Cell>wb_transaction_cg::configuration_nacks</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>11.2</Cell>
				<Cell>Cross ConnSlv-ACK, DisconSlv-NACK</Cell>
				<Cell>Ensure that both cases, connected leading to ACKS and disconnected leading to NACKS, are covered</Cell>
				<Cell>wb_transaction_cg::config_x_nacks</Cell>
				<Cell>Cross</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>11.3</Cell>
				<Cell>Master Receipt of ACKs and NACKs</Cell>
				<Cell>Ensure that WB interface accurately reports both ACKs and NACKs via CMDR[NACK] when expected.</Cell>
				<Cell>wb_transaction_cg::nacks</Cell>
				<Cell>Coverpoint</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
			<Row>
				<Cell>11.4</Cell>
				<Cell>Directed Test of Disconnected Slaves</Cell>
				<Cell>Expect in a multi-bus DUT with no responsive slave or an address mismatch, on an address transmission requesting either read or write, to receive a raised nack at the wb-bus when no slave ACKs the request. Use Random bus selection and random operation type.</Cell>
				<Cell>test_disconnected_slave_nacks</Cell>
				<Cell>test</Cell>
				<Cell>1</Cell>
				<Cell>100</Cell>
			</Row>
		</Table>
	</Worksheet>
</Workbook>
