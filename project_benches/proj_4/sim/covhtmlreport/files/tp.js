var g_data = {"tp":[{"fixed_attr_val":[1308,1240,66.98,66.98,"testplan",1,"testplan","-",0,"0",1],"children":[{"fixed_attr_val":[10,8,60.00,60.00,"testplan",1,"Register Tests",100.00,1,"1",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[1,0,0.00,0.00,"testplan",1,"Register Cross-Checking",100.00,2,"1.1",1],"usr_attr":[{"Description":"Require that writes to one of three writeable registers does not alter values of other registers, except for commands which alter the FSM-States Register, and status response bits in the CMDR"}],"children":[{"fixed_attr_val":[1,0,0.00,"-","test","-","test_register_crosschecking","-"]}]},{"fixed_attr_val":[1,0,0.00,0.00,"testplan",1,"Reg. Access Control",100.00,2,"1.2",1],"usr_attr":[{"Description":"Expect that writes to read-only regions of registers do not change the values stored at these read-only bits"}],"children":[{"fixed_attr_val":[1,0,0.00,"-","test","-","test_register_access_control","-"]}]},{"fixed_attr_val":[2,2,100.00,100.00,"testplan",1,"Reg. Field Accuracy",100.00,2,"1.3",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"CMDR[DONE]",100.00,3,"1.3.1",1],"usr_attr":[{"Description":"Expect DONE bit raised when DUT command operation completed"}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/wb_pkg/wb_monitor/check_command_assertions/assert_done_raised_on_complete",100.00]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"CMDR[NACK]",100.00,3,"1.3.2",1],"usr_attr":[{"Description":"Expect NACK bit raised when no slave response to master request; else low"}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/wb_pkg/wb_monitor/check_command_assertions/assert_nacks_when_expected",100.00]}]}]},{"fixed_attr_val":[4,4,100.00,100.00,"testplan",1,"Default Register Values",100.00,2,"1.4",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"CSR Defaults",100.00,3,"1.4.1",1],"usr_attr":[{"Description":"On a DUT \"soft reset\" with interrupt disabled (Disable-Enable) Expect CSR == 8'b1000_0000, With Interrupt enabled CSR == 8'b1100_0000"}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/wb_pkg/wb_monitor/check_command_assertions/assert_csr_enable_defaults",100.00]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"DPR Default",100.00,3,"1.4.2",1],"usr_attr":[{"Description":"After \"soft reset\" expect DPR == 8'h00"}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/wb_pkg/wb_monitor/check_command_assertions/assert_dpr_default_on_enable",100.00]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"CMDR Default",100.00,3,"1.4.3",1],"usr_attr":[{"Description":"After \"soft reset\" expect CMDR == 8'b1000_0000"}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/wb_pkg/wb_monitor/check_command_assertions/assert_cmdr_default_on_enable",100.00]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"FSMR Default",100.00,3,"1.4.4",1],"usr_attr":[{"Description":"After \"soft reset\" expect FSMR == 8'h00"}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/wb_pkg/wb_monitor/check_command_assertions/assert_fsmr_default_on_enable",100.00]}]}]},{"fixed_attr_val":[2,2,100.00,100.00,"testplan",1,"Require Interrupts from Regblock",100.00,2,"1.5",1],"usr_attr":[{"Description":"When enabled, Require interrupts to be raised by the regblock when DUT has completed operation. Directed and random testflows from the test_multi_bus group will all require an interrupt to be raised when DUT is reporting done."}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","test_multi_bus_max_speed","-"]},{"fixed_attr_val":[1,1,100.00,"-","test","-","test_multi_bus_ranged_speed","-"]}]}]},{"fixed_attr_val":[3,2,66.66,66.66,"testplan",1,"Compulsory Tests",100.00,1,"2",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[1,0,0.00,0.00,"testplan",1,"Base Single-Bus Test",100.00,2,"2.1",1],"usr_attr":[{"Description":"Expect completed transactions with single and multiple bytes,both read and write, with both start-stop and start-restart-stop conditions to complete successfully, with single bus configured to default Speed (100kHz). Use RANDOM addresses, data, message length(zero/single/multibyte) and operations types. Randomly, inject illegal bus selections (bus > 0) and verify DUT operation with illegal selection."}],"children":[{"fixed_attr_val":[1,0,0.00,"-","test","-","test_single_bus_default_speed","-"]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Multi-Bus Max Speed Test",100.00,2,"2.2",1],"usr_attr":[{"Description":"Expect completed transactions on multiple busses with single and multiple bytes,both read and write, with both start-stop and start-restart-stop conditions to complete successfully, with each bus configured to Maximum Speed (400kHz). Use RANDOM Bus Selection, addresses, data,  message length(zero/single/multibyte), and operations types."}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","test_multi_bus_max_speed","-"]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Multi-Bus Simultaneous Ranged Speeds Test",100.00,2,"2.3",1],"usr_attr":[{"Description":"Expect completed transactions on multiple busses with single and multiple bytes,both read and write, with both start-stop and start-restart-stop conditions to complete successfully, with busses configured to a range from (400kHz) to (10kHz) Use RANDOM Bus Selection, addresses, data,  message length(zero/single/multibyte), and operations types."}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","test_multi_bus_ranged_speed","-"]}]}]},{"fixed_attr_val":[3,3,100.00,100.00,"testplan",1,"Arbitration",100.00,1,"3",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[2,2,100.00,100.00,"testplan",2,"Arbitration Lost (All Busses)",100.00,2,"3.1",1],"usr_attr":[{"Description":"In the presence of a simulated multi-master transmitting at the same time (BFM write 0, DUT write 1), expect DUT to lose arbitration. Require behavior across all available i2c busses."}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"CMDR[ARB_LOST]",100.00,3,"3.1.1",1],"usr_attr":[{"Description":"Require \"Arbitration Lost\" bit in the CMDR to rise when master has lost arbitration negotiation"}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/wb_pkg/wb_driver/bl_arb_put/assert_require_arb_loss_bit",100.00]}]},{"fixed_attr_val":[1,1,100.00,"-","test","-","test_arbitration_lost_scenario","-"]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Arbitration Won CMDR[ARB_LOST]",100.00,2,"3.2",1],"usr_attr":[{"Description":"In the presence of a real multi-master configuration, expect Arbitration lost bit of CMDR to be low upon arbitration win"}],"children":[{"fixed_attr_val":[1,1,100.00,100.00,"assert",1,"/wb_pkg/wb_monitor/check_command_assertions/assert_arbitration_won",100.00]}]}]},{"fixed_attr_val":[75,74,99.68,99.68,"testplan",1,"Clock-Stretching and WB Waits",100.00,1,"4",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[4,4,100.00,100.00,"testplan",1,"Slave-End Clock Stretching  (Any Bus)",100.00,2,"4.1",1],"usr_attr":[{"Description":"Expect transfers to complete when TB delays subsequent operations legally from the I2c-interface via I2c  Clock Stretching (scl held low at legal times (after receive address/data bit, after transmit ACK/NACK, Before transmit \"read\" data bit)"}],"children":[{"fixed_attr_val":[4,4,100.00,100.00,"coverpoint",1,"/i2c_pkg/i2c_coverage/clockstretch_cg/i2c_stretch_delay",100.00]}]},{"fixed_attr_val":[64,63,98.43,98.43,"testplan",1,"Slave-End Clock Stretching  (All Busses)",100.00,2,"4.2",1],"usr_attr":[{"Description":"Expect clockstretching to apply and work as described in 4.1, across all available busses"}],"children":[{"fixed_attr_val":[64,63,98.43,98.43,"cross",1,"/i2c_pkg/i2c_coverage/clockstretch_cg/stretch_x_bus_sel",100.00]}]},{"fixed_attr_val":[3,3,100.00,100.00,"testplan",1,"Master-End Upstream Delays",100.00,2,"4.3",1],"usr_attr":[{"Description":"Expect transfers to complete when TB delays operations on the WB end of the DUT, via stalling continued commands after a completed read or write. REQUIRE no extraneous starts/stops or clock cycles during these stalls."}],"children":[{"fixed_attr_val":[3,3,100.00,100.00,"coverpoint",1,"/wb_pkg/wb_coverage/wb_transaction_cg/wb_stretch_delay",100.00]}]},{"fixed_attr_val":[3,3,100.00,100.00,"testplan",1,"Wait Commands",100.00,2,"4.4",1],"usr_attr":[{"Description":"Expect transfers to complete when explicit wait commands issues to DUT with subsequent operations"}],"children":[{"fixed_attr_val":[3,3,100.00,100.00,"coverpoint",1,"/i2cmb_env_pkg/i2cmb_predictor/wait_cg/explicit_wait_times",100.00]}]},{"fixed_attr_val":[1,1,100.00,100.00,"testplan",1,"Directed Clockstretching Test",100.00,2,"4.5",1],"usr_attr":[{"Description":"Initiate required clockstretched transfers to meet coverage in all coverpoints and crosses for Clockstretching group. Use randomized time quantities for clocks to be slowed. Require successful transfers in single, multi-byte, and bidirectional, in the presence of stretched clocks. Use RANDOM Bus Selection, addresses, data, and operations types. Use RANDOM CLOCKSTRETCH DURATIONS. Insert RANDOM WB-end delays. Insert RANDOM explicit WAIT commands via DUT."}],"children":[{"fixed_attr_val":[1,1,100.00,"-","test","-","test_clockstretching","-"]}]}]},{"fixed_attr_val":[4,0,0.00,0.00,"testplan",1,"Soft Resets and Interrupts",100.00,1,"5",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[1,0,0.00,0.00,"testplan",1,"Intr-Intr Reset",100.00,2,"5.1",1],"usr_attr":[{"Description":"After an Enable-Transfers-Disable-Enable, with interrupts enabled for both enable commands, expect subsequent transfers to complete successfully, with interrupt signal being raised by DUT to signal done"}],"children":[{"fixed_attr_val":[1,0,0.00,"-","test","-","test_enable_disable_enable_intr_x_poll","-"]}]},{"fixed_attr_val":[1,0,0.00,0.00,"testplan",1,"Intr-Poll Reset",100.00,2,"5.2",1],"usr_attr":[{"Description":"After an Enable-Transfers-Disable-Enable, with interrupts enabled for first command, and disabled for second \"enable\" command, expect subsequent transfers to complete successfully, WITHOUT Interrupt signal being raised by DUT to signal done"}],"children":[{"fixed_attr_val":[1,0,0.00,"-","test","-","test_enable_disable_enable_intr_x_poll","-"]}]},{"fixed_attr_val":[1,0,0.00,0.00,"testplan",1,"Poll-Intr Reset",100.00,2,"5.3",1],"usr_attr":[{"Description":"After an Enable-Transfers-Disable-Enable, with interrupts DISabled for first command, and ENabled for second \"enable\" command, expect subsequent transfers to complete successfully, WITH Interrupt signal being raised by DUT to signal done"}],"children":[{"fixed_attr_val":[1,0,0.00,"-","test","-","test_enable_disable_enable_intr_x_poll","-"]}]},{"fixed_attr_val":[1,0,0.00,0.00,"testplan",1,"Poll-Poll Reset",100.00,2,"5.4",1],"usr_attr":[{"Description":"After an Enable-Transfers-Disable-Enable, with interrupts DISabled for first command, and DISabled for second \"enable\" command, expect subsequent transfers to complete successfully, WITHOUT Interrupt signal being raised by DUT to signal done"}],"children":[{"fixed_attr_val":[1,0,0.00,"-","test","-","test_enable_disable_enable_intr_x_poll","-"]}]}]},{"fixed_attr_val":[1,0,0.00,0.00,"testplan",1,"Hard Resets",100.00,1,"6",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[1,0,0.00,0.00,"testplan",1,"Hard rst via rst signal between xfers",100.00,2,"6.1",1],"usr_attr":[{"Description":"When a 133ns reset is raised after a completed transfer, expect subsequent enable-transfer flows to complete successfully"}],"children":[{"fixed_attr_val":[1,0,0.00,"-","test","-","test_hard_reset_insertion","-"]}]}]},{"fixed_attr_val":[183,167,89.62,89.62,"testplan",1,"FSM Testing",100.00,1,"7",1],"usr_attr":[{"Description":"Require that code coverage reports 100% FSM State and Transition arc coverage within DUT, for all DUT FSMs"}],"children":[{"fixed_attr_val":[25,21,88.23,88.23,"testplan",1,"Byte-Level FSM Coverage",100.00,2,"7.1",1],"usr_attr":[{"Description":"State and Transition coverage for i2cmb Byte-Level FSM"}],"children":[{"fixed_attr_val":[25,21,88.23,88.23,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/mbyte_inst0/state",100.00]}]},{"fixed_attr_val":[46,34,80.64,80.64,"testplan",1,"Bit-Level FSM Coverage",100.00,2,"7.2",1],"usr_attr":[{"Description":"State and Transition coverage for i2cmb Bit-Level FSM"}],"children":[{"fixed_attr_val":[46,34,80.64,80.64,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/mbit_inst0/state",100.00]}]},{"fixed_attr_val":[112,112,100.00,100.00,"testplan",1,"Bus Conditioner FSMs",100.00,2,"7.3",1],"usr_attr":[{"Description":"State and Transition Coverage for i2cmb Bus-Conditioner FSMs"}],"children":[{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(0)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(1)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(2)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(3)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(4)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(5)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(6)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(7)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(8)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(9)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(10)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(11)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(12)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(13)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(14)/conditioner_inst0/bus_state_inst0/state",100.00]},{"fixed_attr_val":[7,7,100.00,100.00,"fsm",1,"/top/DUT_16_max/iicmb_m_inst0/conditioner_mux_inst0/scl_sda_gen(15)/conditioner_inst0/bus_state_inst0/state",100.00]}]}]},{"fixed_attr_val":[400,385,84.31,84.31,"testplan",1,"DUT Code Coverage",100.00,1,"8",1],"usr_attr":[{"Description":"RTL Core ALL stmt, brnch, fsm, trans, expr. Require that all DUT units have 100% statement coverage and 100% branch coverage."}],"children":[{"fixed_attr_val":[400,385,84.31,84.31,"instance",1,"/top/DUT_16_max",100.00]}]},{"fixed_attr_val":[608,584,99.02,99.02,"testplan",1,"I2C Protocol Testing",100.00,1,"9",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[128,128,100.00,100.00,"testplan",1,"I2C Addresses",100.00,2,"9.1",1],"usr_attr":[{"Description":"Ensure all addresses have been selected and used for successful transfers"}],"children":[{"fixed_attr_val":[128,128,100.00,100.00,"coverpoint",1,"/i2c_pkg/i2c_coverage/i2c_transaction_cg/address",100.00]}]},{"fixed_attr_val":[64,64,100.00,100.00,"testplan",1,"I2C Data Values",100.00,2,"9.2",1],"usr_attr":[{"Description":"Ensure all possible data values have been selected and used for successful transfer"}],"children":[{"fixed_attr_val":[64,64,100.00,100.00,"coverpoint",1,"/i2c_pkg/i2c_coverage/i2c_transaction_cg/data",100.00]}]},{"fixed_attr_val":[16,16,100.00,100.00,"testplan",1,"I2C Bus Selection",100.00,2,"9.3",1],"usr_attr":[{"Description":"Ensure all available data busses have been properly tested"}],"children":[{"fixed_attr_val":[16,16,100.00,100.00,"coverpoint",1,"/i2c_pkg/i2c_coverage/i2c_transaction_cg/bus_sel",100.00]}]},{"fixed_attr_val":[2,2,100.00,100.00,"testplan",1,"I2C Operation Type",100.00,2,"9.4",1],"usr_attr":[{"Description":"Ensure both reads and writes are covered"}],"children":[{"fixed_attr_val":[2,2,100.00,100.00,"coverpoint",1,"/i2c_pkg/i2c_coverage/i2c_transaction_cg/operation",100.00]}]},{"fixed_attr_val":[3,3,100.00,100.00,"testplan",1,"I2C Message Size (Single and Multi-Byte)",100.00,2,"9.5",1],"usr_attr":[{"Description":"Ensure DUT properly handles Zero-data, single-byte, and multi-byte transactions"}],"children":[{"fixed_attr_val":[3,3,100.00,100.00,"coverpoint",1,"/i2c_pkg/i2c_coverage/i2c_transaction_cg/msg_size",100.00]}]},{"fixed_attr_val":[2,2,100.00,100.00,"testplan",1,"I2C START and RE-START",100.00,2,"9.6",1],"usr_attr":[{"Description":"Ensure that DUT properly handles both START (from idle) and RE-START (From transaction-in-progress) initiations of new transactions."}],"children":[{"fixed_attr_val":[2,2,100.00,100.00,"coverpoint",1,"/i2cmb_env_pkg/i2cmb_predictor/predictor_cg/start_or_restart",100.00]}]},{"fixed_attr_val":[5,5,100.00,100.00,"testplan",1,"Operation Vs Msg Size",100.00,2,"9.7",1],"usr_attr":[{"Description":"Ensure that all message sizes are used in both I2C Read and Write transaction types"}],"children":[{"fixed_attr_val":[5,5,100.00,100.00,"cross",1,"/i2c_pkg/i2c_coverage/i2c_transaction_cg/msg_size_x_operation",100.00]}]},{"fixed_attr_val":[128,127,99.21,99.21,"testplan",1,"Operation Vs Data",100.00,2,"9.8",1],"usr_attr":[{"Description":"Ensure that all legal data values are covered across  both I2C Read and Write transaction types"}],"children":[{"fixed_attr_val":[128,127,99.21,99.21,"cross",1,"/i2c_pkg/i2c_coverage/i2c_transaction_cg/operation_x_data",100.00]}]},{"fixed_attr_val":[256,233,91.01,91.01,"testplan",1,"Operation  Vs Address",100.00,2,"9.9",1],"usr_attr":[{"Description":"Ensure that all valid address values are covered for  both I2C Read and Write transaction types"}],"children":[{"fixed_attr_val":[256,233,91.01,91.01,"cross",1,"/i2c_pkg/i2c_coverage/i2c_transaction_cg/operation_x_address",100.00]}]},{"fixed_attr_val":[4,4,100.00,100.00,"testplan",1,"Operation vs Start-Restart",100.00,2,"9.10",1],"usr_attr":[{"Description":"Ensure that start-restart conditions are covered for both read and write transaction types."}],"children":[{"fixed_attr_val":[4,4,100.00,100.00,"cross",1,"/i2cmb_env_pkg/i2cmb_predictor/predictor_cg/restart_x_operation",100.00]}]}]},{"fixed_attr_val":[14,14,100.00,100.00,"testplan",1,"WB Protocol Testing",100.00,1,"10",1],"usr_attr":[{"Description":""}],"children":[{"fixed_attr_val":[10,10,100.00,100.00,"testplan",1,"WB Command Coverage",100.00,2,"10.1",1],"usr_attr":[{"Description":"Ensure that all possible WB transactions and commands have been used as part of overall testplan"}],"children":[{"fixed_attr_val":[10,10,100.00,100.00,"coverpoint",1,"/wb_pkg/wb_coverage/wb_transaction_cg/cmd_type",100.00]}]},{"fixed_attr_val":[4,4,100.00,100.00,"testplan",1,"WB Register Coverage",100.00,2,"10.2",1],"usr_attr":[{"Description":"TODO TODO TODO"}],"children":[{"fixed_attr_val":[4,4,100.00,100.00,"coverpoint",1,"/wb_pkg/wb_coverage/wb_transaction_cg/reg_type",100.00]}]}]},{"fixed_attr_val":[7,3,37.50,37.50,"testplan",1,"Connected and Disconnected Slave",100.00,1,"11",1],"usr_attr":[{"Description":"Ensure NACKs are passed to WB interface when no slave response detected; otherwise, expect ACKS on WB-End"}],"children":[{"fixed_attr_val":[2,1,50.00,50.00,"testplan",1,"Config Slave Connected or Disconnected",100.00,2,"11.1",1],"usr_attr":[{"Description":"Expect NACK bit raised when no slave response to master request"}],"children":[{"fixed_attr_val":[2,1,50.00,50.00,"coverpoint",1,"/wb_pkg/wb_coverage/wb_transaction_cg/configuration_nacks",100.00]}]},{"fixed_attr_val":[2,1,50.00,50.00,"testplan",1,"Cross ConnSlv-ACK, DisconSlv-NACK",100.00,2,"11.2",1],"usr_attr":[{"Description":"Ensure that both cases, connected leading to ACKS and disconnected leading to NACKS, are covered"}],"children":[{"fixed_attr_val":[2,1,50.00,50.00,"cross",1,"/wb_pkg/wb_coverage/wb_transaction_cg/config_x_nacks",100.00]}]},{"fixed_attr_val":[2,1,50.00,50.00,"testplan",1,"Master Receipt of ACKs and NACKs",100.00,2,"11.3",1],"usr_attr":[{"Description":"Ensure that WB interface accurately reports both ACKs and NACKs via CMDR[NACK] when expected."}],"children":[{"fixed_attr_val":[2,1,50.00,50.00,"coverpoint",1,"/wb_pkg/wb_coverage/wb_transaction_cg/nacks",100.00]}]},{"fixed_attr_val":[1,0,0.00,0.00,"testplan",1,"Directed Test of Disconnected Slaves",100.00,2,"11.4",1],"usr_attr":[{"Description":"Expect in a multi-bus DUT with no responsive slave or an address mismatch, on an address transmission requesting either read or write, to receive a raised nack at the wb-bus when no slave ACKs the request. Expect NACKs raised after each data byte written. Use Random bus selection, random operation type, and in case of writes, random message length and data."}],"children":[{"fixed_attr_val":[1,0,0.00,"-","test","-","test_disconnected_slave_nacks","-"]}]}]}]}],"head":["Description"]};
processTpLinks(g_data);